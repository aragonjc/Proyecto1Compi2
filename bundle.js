(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (process){
/* parser generated by jison 0.4.18 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var AST = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,6],$V1=[1,13],$V2=[1,15],$V3=[1,16],$V4=[1,17],$V5=[1,18],$V6=[1,19],$V7=[1,20],$V8=[1,21],$V9=[1,22],$Va=[5,9,10,30,42,47,48,49,57,58,81],$Vb=[1,32],$Vc=[2,15],$Vd=[1,30],$Ve=[1,31],$Vf=[1,33],$Vg=[1,34],$Vh=[1,35],$Vi=[1,36],$Vj=[1,37],$Vk=[1,38],$Vl=[5,9,10,14,30,38,39,40,42,47,48,49,53,56,57,58,81],$Vm=[2,14],$Vn=[5,9,10,14,15,25,30,38,39,40,42,47,48,49,53,56,57,58,81],$Vo=[1,60],$Vp=[1,53],$Vq=[1,61],$Vr=[1,51],$Vs=[1,52],$Vt=[1,54],$Vu=[1,55],$Vv=[1,56],$Vw=[1,57],$Vx=[1,58],$Vy=[1,59],$Vz=[1,65],$VA=[15,28],$VB=[2,95],$VC=[1,72],$VD=[1,71],$VE=[1,85],$VF=[1,86],$VG=[1,87],$VH=[2,17],$VI=[1,111],$VJ=[1,112],$VK=[1,96],$VL=[1,97],$VM=[1,98],$VN=[1,99],$VO=[1,100],$VP=[1,101],$VQ=[1,102],$VR=[1,103],$VS=[1,104],$VT=[1,105],$VU=[1,106],$VV=[1,107],$VW=[1,108],$VX=[1,109],$VY=[1,110],$VZ=[5,9,10,11,14,15,25,28,30,33,38,39,40,42,47,48,49,53,56,57,58,61,62,69,76,77,81,89,90,91,92,93,94,95,96,97,98,99,100,101,102,104],$V_=[5,9,10,11,14,15,23,25,28,30,33,38,39,40,42,47,48,49,53,56,57,58,61,62,69,72,73,74,75,76,77,81,89,90,91,92,93,94,95,96,97,98,99,100,101,102,104],$V$=[2,76],$V01=[5,9,10,14,15,25,28,30,38,39,40,42,47,48,49,53,56,57,58,69,81],$V11=[1,126],$V21=[1,134],$V31=[1,130],$V41=[1,131],$V51=[1,132],$V61=[1,133],$V71=[10,14,38,39,40,42,47,48,49,53,56,57,58,81],$V81=[1,153],$V91=[1,154],$Va1=[1,158],$Vb1=[25,28],$Vc1=[28,69],$Vd1=[1,184],$Ve1=[1,183],$Vf1=[14,15,28],$Vg1=[11,12,14,15,25,28],$Vh1=[2,102],$Vi1=[1,192],$Vj1=[10,23,68,90,103,105,106,107,108,109,110],$Vk1=[5,9,10,11,14,15,25,28,30,33,38,39,40,42,47,48,49,53,56,57,58,61,62,69,81,89,90,95,96,97,98,99,100,101,102,104],$Vl1=[5,9,10,11,14,15,25,28,30,33,38,39,40,42,47,48,49,53,56,57,58,61,62,69,81,89,90,91,92,94,95,96,97,98,99,100,101,102,104],$Vm1=[5,9,10,11,14,15,25,28,30,33,38,39,40,42,47,48,49,53,56,57,58,61,62,69,81,95,96,97,98,99,100,101,102,104],$Vn1=[1,235],$Vo1=[11,12,14,15,25,28,68],$Vp1=[1,257],$Vq1=[2,43],$Vr1=[1,269],$Vs1=[14,53,56];
var parser = {trace: function trace () { },
yy: {},
symbols_: {"error":2,"S":3,"Bloque":4,"EOF":5,"Instruccion":6,"llamadaFuncion":7,"variables":8,"Type":9,"id":10,"igual":11,"curlyBraceOpen":12,"parsObj":13,"curlyBraceClose":14,"semicolon":15,"funciones":16,"IF":17,"WHILE":18,"DOWHILE":19,"SWITCH":20,"FOR":21,"PL":22,"bracketOpen":23,"paramFunc":24,"bracketClose":25,"varLast":26,"paramFuncList":27,"comma":28,"E":29,"function":30,"funcParam":31,"funcDec":32,"dosPuntos":33,"types":34,"STMT":35,"funcParamList":36,"InstruccionI":37,"Break":38,"Continue":39,"return":40,"OP":41,"if":42,"exp":43,"IFLAST":44,"else":45,"IFCOND":46,"while":47,"do":48,"switch":49,"FIRSTCASE":50,"LASTCASE":51,"CASE":52,"case":53,"DEFCASE":54,"ENDCASE":55,"default":56,"for":57,"let":58,"asignLast":59,"forOP":60,"in":61,"of":62,"defVarLast":63,"defVarLastP":64,"defLast":65,"defType":66,"asignLastF":67,"sqBracketOpen":68,"sqBracketClose":69,"auxP":70,"point":71,"masIgual":72,"menosIgual":73,"porIgual":74,"divisionIgual":75,"increment":76,"decrement":77,"objType":78,"opkv":79,"keyvalueT":80,"const":81,"number":82,"typesList":83,"boolean":84,"string":85,"void":86,"typesL":87,"objetoParam":88,"mas":89,"menos":90,"por":91,"division":92,"potencia":93,"modulo":94,"mayorque":95,"menorque":96,"mayorigualque":97,"menorigualque":98,"igualdad":99,"diferencia":100,"and":101,"or":102,"not":103,"question":104,"NUMBER":105,"STRING":106,"true":107,"false":108,"null":109,"undefined":110,"arrParam":111,"listArrParam":112,"objetoParamList":113,"keyvalue":114,"$accept":0,"$end":1},
terminals_: {2:"error",5:"EOF",9:"Type",10:"id",11:"igual",12:"curlyBraceOpen",14:"curlyBraceClose",15:"semicolon",23:"bracketOpen",25:"bracketClose",28:"comma",30:"function",33:"dosPuntos",38:"Break",39:"Continue",40:"return",42:"if",45:"else",47:"while",48:"do",49:"switch",53:"case",56:"default",57:"for",58:"let",61:"in",62:"of",68:"sqBracketOpen",69:"sqBracketClose",71:"point",72:"masIgual",73:"menosIgual",74:"porIgual",75:"divisionIgual",76:"increment",77:"decrement",81:"const",82:"number",84:"boolean",85:"string",86:"void",89:"mas",90:"menos",91:"por",92:"division",93:"potencia",94:"modulo",95:"mayorque",96:"menorque",97:"mayorigualque",98:"menorigualque",99:"igualdad",100:"diferencia",101:"and",102:"or",103:"not",104:"question",105:"NUMBER",106:"STRING",107:"true",108:"false",109:"null",110:"undefined"},
productions_: [0,[3,2],[4,2],[4,1],[6,1],[6,1],[6,7],[6,1],[6,1],[6,1],[6,1],[6,1],[6,1],[7,6],[22,1],[22,0],[24,1],[24,0],[27,3],[27,1],[16,6],[32,5],[32,3],[31,1],[31,0],[36,5],[36,3],[35,2],[35,1],[37,1],[37,1],[37,1],[37,1],[37,1],[37,1],[37,1],[37,2],[37,2],[37,2],[41,2],[41,1],[17,8],[44,2],[44,0],[46,8],[46,3],[18,7],[19,9],[20,8],[50,1],[50,0],[52,5],[52,4],[51,2],[54,3],[55,1],[55,0],[21,15],[21,14],[21,12],[21,10],[21,9],[60,1],[60,1],[63,2],[63,0],[64,4],[64,2],[8,5],[8,3],[8,2],[59,2],[59,1],[26,4],[26,3],[70,1],[70,0],[67,2],[67,2],[67,2],[67,2],[67,2],[67,1],[67,1],[13,1],[13,0],[78,3],[78,1],[79,1],[79,1],[80,3],[66,1],[66,1],[65,4],[65,2],[65,0],[34,2],[34,2],[34,2],[34,2],[34,2],[83,1],[83,0],[87,3],[87,2],[29,1],[29,3],[43,3],[43,3],[43,3],[43,3],[43,2],[43,3],[43,3],[43,3],[43,3],[43,3],[43,3],[43,3],[43,3],[43,3],[43,3],[43,2],[43,3],[43,5],[43,2],[43,2],[43,1],[43,1],[43,1],[43,1],[43,1],[43,1],[43,2],[43,1],[43,5],[43,3],[111,1],[111,0],[112,3],[112,1],[88,1],[88,0],[113,3],[113,1],[114,3]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
 
	contador++;
	return ast.Node(contador,"S",$$[$0-1],null);	
	 

break;
case 2: case 27:
 
			contador++;
			this.$ = ast.Node(contador,"Bloque",$$[$0-1],$$[$0]);
		
break;
case 3:
 
		contador++;
		this.$ = ast.Node(contador,"Instruccion",$$[$0],null);
	
break;
case 4: case 7: case 8: case 10: case 11: case 12: case 29: case 30: case 31: case 32: case 33: case 34: case 35:
 this.$=$$[$0]; 
break;
case 5: case 9: case 16:
 this.$=$$[$0];
break;
case 6:

				contador++;
				var id = ast.Leaf(contador,$$[$0-5]);
				contador++;
				var igual = ast.Leaf(contador,"=");
				contador++;
				var curlyO = ast.Leaf(contador,"\"{\"")
				contador++;
				var curlyC = ast.Leaf(contador,"\"}\"")
				var arr = [];
				arr.push(id)
				arr.push(igual)
				arr.push(curlyO)
				if($$[$0-2]) {
					arr.push($$[$0-2])
				}
				arr.push(curlyC)

				contador++;
				this.$ = ast.Node(contador,"TYPE",arr,null);
			
break;
case 13:

					contador++;
					var id = ast.Leaf(contador,$$[$0-5]);
					contador++;
					var bkOp = ast.Leaf(contador,"ParentesisAbre")
					contador++;
					var bkC = ast.Leaf(contador,"ParentesisCierra")
					var arr = [];
					arr.push(id)
					if($$[$0-4]!=null) {
						arr.push($$[$0-4])
					}
					arr.push(bkOp)
					if($$[$0-2]) {
						arr.push($$[$0-2])
					}
					arr.push(bkC)
					contador++;
					this.$ = ast.Node(contador,"LlamadaFuncion",arr,null);
				
break;
case 14:
this.$= $$[$0];
break;
case 15: case 85: case 138:
this.$ = null;
break;
case 17:
 this.$=null;
break;
case 18:

					  contador++;
					  this.$ = ast.Node(contador,"listaParametros",$$[$0-2],$$[$0]);
					
break;
case 19: case 84: case 88: case 89:
this.$ = $$[$0];
break;
case 20:

		contador++;
		var id = ast.Leaf(contador,$$[$0-4]);
		contador++;
		var bo = ast.Leaf(contador,"ParentesisAbre")
		contador++;
		var bc = ast.Leaf(contador,"ParentesisCierre")
		var arr = []
		arr.push(id)
		arr.push(bo)
		if($$[$0-2]) {
			arr.push($$[$0-2])
		}
		arr.push(bc)
		if($$[$0].hasOwnProperty("type")) {
			arr.push($$[$0].type)
			arr.push($$[$0].value)
		} else {
			arr.push($$[$0].value)
		}
		contador++;
		this.$ = ast.Node(contador,"Funcion",arr,null)


break;
case 21:

			contador++;
			var type = ast.Leaf(contador,$$[$0-3])
			this.$ = {value:$$[$0-1],type:type}
		
break;
case 22:

			this.$ = {value:$$[$0-1]};	
		
break;
case 23:
 this.$ =$$[$0];
break;
case 24: case 40: case 43: case 50: case 56: case 95:
 this.$ = null; 
break;
case 25:

					contador++;
				  	var id = ast.Leaf(contador,$$[$0-2]);
				  	contador++;
				  	var types = ast.Leaf(contador,$$[$0]);
				  	contador++;
				  	var param = ast.Node(contador,"Parametro",id,types)
					contador++;
					this.$ = ast.Node(contador,"ListaParametro",$$[$0-4],param)
			   
break;
case 26:

				  contador++;
				  var id = ast.Leaf(contador,$$[$0-2]);
				  contador++;
				  var types = ast.Leaf(contador,$$[$0]);
				  contador++;
				  this.$ = ast.Node(contador,"Parametro",id,types)
			  
break;
case 28:
 
		contador++;
		this.$ = ast.Node(contador,"Instruccion",$$[$0],null);
	 
break;
case 36:
 
				contador++;
				this.$ = ast.Leaf(contador,"Break"); 
			
break;
case 37:

				contador++;
				this.$ = ast.Leaf(contador,"Continue"); 
			
break;
case 38:
 
				contador++;
				this.$ = ast.Node(contador,"RETURN",$$[$0],null);
			
break;
case 39:
 this.$ = $$[$0-1];
break;
case 41:
 
		contador++;
		var Condicion = ast.Node(contador,"Condicion",$$[$0-5],null)
		contador++;
		var IF_STMT = ast.Node(contador,"IF",[Condicion,$$[$0-2]],$$[$0])
		this.$ = IF_STMT;
	
break;
case 42:
 
			contador++;
		   	this.$ = ast.Node(contador,"ELSE",$$[$0],null);
		
break;
case 44:

		   contador++;
		   var conditon = ast.Node(contador,"Condicion",$$[$0-5],null);
		   contador++;
		   this.$ = ast.Node(contador,"IF",[conditon,$$[$0-2]],$$[$0])
	   
break;
case 45:

		   this.$ = $$[$0-1];
	   
break;
case 46:

			contador++;
			var condition = ast.Node(contador,"Condicion",$$[$0-4],null)
			contador++;
			this.$=  ast.Node(contador,"WHILE",condition,$$[$0-1])
		
break;
case 47:

			contador++;
			var condition = ast.Node(contador,"Condicion",$$[$0-2],null)
			contador++;
			this.$ =  ast.Node(contador,"DOWHILE",$$[$0-6],condition)
		
break;
case 48:

			contador++;
			var param = [];
			param.push($$[$0-5]);
			if($$[$0-2] != null) {
				param.push($$[$0-2])
			}
			if($$[$0-1] != null) {
				param.push($$[$0-1])
			}
			this.$ = ast.Node(contador,"SWITCH",param,null)
		
break;
case 49:
this.$ =$$[$0]; 
break;
case 51:

		contador++;
		var caseT = ast.Node(contador,"CASE",$$[$0-2],$$[$0]);
		contador++;
		this.$ = ast.Node(contador,"CaseList",$$[$0-4],caseT);
	 
break;
case 52:

		contador++;
		this.$ = ast.Node(contador,"CASE",$$[$0-2],$$[$0]);
	 
break;
case 53:

		this.$ = $$[$0-1];
	
break;
case 54:

	contador++;
	this.$ = ast.Node(contador,"DEFAULT",$$[$0],null)

break;
case 55: case 62: case 63: case 91: case 92: case 137: case 141:
 this.$ = $$[$0]; 
break;
case 57:

		contador++;
		var dect = ast.Leaf(contador,"let");
		contador++;
		var id = ast.Leaf(contador,$$[$0-11]);
		contador++;
		var igual = ast.Leaf(contador,"=");
		var asign = [dect,id,igual,$$[$0-9]]
		
		contador++;
		var asignacion = ast.Node(contador,"ASIGNACION",asign,null);
		
		contador++;
		var condicion = ast.Node(contador,"CONDICION",$$[$0-7],null);
		
		var arr = [];
		arr.push(asignacion)
		arr.push(condicion)
		
		if($$[$0-4].hasOwnProperty("varlast")) {
			contador++;
			var id = ast.Leaf(contador,$$[$0-5]);
			if($$[$0-4].value.length == 2) {
				contador++;
				var inc = ast.Node(contador,$$[$0-4].value[0],id,$$[$0-4].value[1])
				arr.push(inc)
			} else {
				contador++;
				var inc = ast.Node(contador,$$[$0-4].value[0],id,null);
				arr.push(inc)
			}
			
		} else {
			contador++;
			var id = ast.Leaf(contador,$$[$0-5]);
			if($$[$0-4].value.length == 2) {
				contador++;
				var inc = ast.Node(contador,$$[$0-4].value[0],id,$$[$0-4].value[1])
				arr.push(inc)
			} else {
				contador++;
				var inc = ast.Node(contador,$$[$0-4].value[0],id,null);
				arr.push(inc)
			}
		}
		arr.push($$[$0-1])
		contador++;
		this.$ = ast.Node(contador,"FOR",arr,null)
		
	
break;
case 58:

		
		
		contador++;
		var igual = ast.Leaf(contador,"=");

		var asign = [$$[$0-11],igual,$$[$0-9]]
		
		contador++;
		var asignacion = ast.Node(contador,"ASIGNACION",asign,null);
		
		contador++;
		var condicion = ast.Node(contador,"CONDICION",$$[$0-7],null);
		
		var arr = [];
		arr.push(asignacion)
		arr.push(condicion)
		
		if($$[$0-4].hasOwnProperty("varlast")) {
			contador++;
			var id = ast.Leaf(contador,$$[$0-5]);
			arr.push(id)
			arr.push($$[$0-4].varlast)
		} else {
			contador++;
			var id = ast.Leaf(contador,$$[$0-5]);
			if($$[$0-4].value.length == 2) {
				contador++;
				var inc = ast.Node(contador,$$[$0-4].value[0],id,$$[$0-4].value[1])
				arr.push(inc)
			} else {
				contador++;
				var inc = ast.Node(contador,$$[$0-4].value[0],id,null);
				arr.push(inc)
			}
		}
		arr.push($$[$0-1])
		contador++;
		this.$ = ast.Node(contador,"FOR",arr,null)
	
break;
case 59:

		
		
		contador++;
		var asignacion = ast.Node(contador,"ASIGNACION",$$[$0-9],null);
		
		contador++;
		var condicion = ast.Node(contador,"CONDICION",$$[$0-7],null);
		
		var arr = [];
		arr.push(asignacion)
		arr.push(condicion)
		
		if($$[$0-4].hasOwnProperty("varlast")) {
			contador++;
			var id = ast.Leaf(contador,$$[$0-5]);
			arr.push(id)
			arr.push($$[$0-4].varlast)
		} else {
			contador++;
			var id = ast.Leaf(contador,$$[$0-5]);
			
			if($$[$0-4].value.length == 2) {
				contador++;
				var inc = ast.Node(contador,$$[$0-4].value[0],id,$$[$0-4].value[1])
				arr.push(inc)
			} else {
				contador++;
				var inc = ast.Node(contador,$$[$0-4].value[0],id,null);
				arr.push(inc)
			}
		}
		arr.push($$[$0-1])
		contador++;
		this.$ = ast.Node(contador,"FOR",arr,null)
	
break;
case 60:

		contador++;
		var dec = ast.Leaf(contador,"let")
		contador++;
		var id = ast.Leaf(contador,$$[$0-6])
		contador++;
		var forOP = ast.Leaf(contador,$$[$0-5])
		var arr = []
		arr.push(dec)
		arr.push(id)
		arr.push(forOP)
		arr.push($$[$0-4])
		arr.push($$[$0-1])
		contador++;
		this.$ = ast.Node(contador,"FOR",arr,null)


	
break;
case 61:

		
		
		contador++;
		var forOP = ast.Leaf(contador,$$[$0-5])
		var arr = []
		arr.push($$[$0-6])
		arr.push(forOP)
		arr.push($$[$0-4])
		arr.push($$[$0-1])
		contador++;
		this.$ = ast.Node(contador,"FOR",arr,null)
	
break;
case 64:

				contador++;
				var comma = ast.Leaf(contador,",");
				contador++;
				this.$ = ast.Node(contador,"defVar",comma,$$[$0]);
			
break;
case 65:
this.$=null;
break;
case 66:

				var result;
				contador++;
				var comma = ast.Leaf(contador,",");
				contador++;
				var id = ast.Leaf(contador,$$[$0-1]);
				if($$[$0] == null){
					result = ast.Node(contador,"defVarList",[$$[$0-3],comma,id],null)
				} else {
					if($$[$0].hasOwnProperty("type")) {
						contador++;
						var par3 = ast.Leaf(contador,$$[$0].type);
						contador++;
						result = ast.Node(contador,"defVarList",[$$[$0-3],comma,id,par3,$$[$0].value],null);
					} else {
						contador++;
						result = ast.Node(contador,"defVarList",[$$[$0-3],comma,id,$$[$0].value],null);
					}
				}
				this.$ = result;
			
break;
case 67:

				var result;
				contador++;
				var id = ast.Leaf(contador,$$[$0-1]);
				if($$[$0] == null) {
					result = ast.Node(contador,"defVarList",id,null)
				} else {
					if($$[$0].hasOwnProperty("type")) {
						contador++;
						var par3 = ast.Leaf(contador,$$[$0].type);
						contador++;
						result = ast.Node(contador,"defVarList",[id,par3,$$[$0].value],null);
					} else {
						contador++;
						result = ast.Node(contador,"defVarList",[id,$$[$0].value],null);
					}
				}
				this.$ = result;
			
break;
case 68:

				contador++;
				var decType = ast.Leaf(contador,$$[$0-4]);
				contador++;
				var id = ast.Leaf(contador,$$[$0-3]);

				var result;
				if($$[$0-2] == null) {
					contador++;
					result = ast.Node(contador,"Asignacion",[decType,id],$$[$0-1]);
				} else {
					var par3;
					if($$[$0-2].hasOwnProperty("type")) {
						contador++;
						par3 = ast.Leaf(contador,$$[$0-2].type);
						contador++;
						result = ast.Node(contador,"Asignacion",[decType,id,par3,$$[$0-2].value],$$[$0-1]);
					} else {
						contador++;
						result = ast.Node(contador,"Asignacion",[decType,id,$$[$0-2].value],$$[$0-1]);
					}
					this.$ = result;
				}
			
break;
case 69:
	
			  var r;
			  if($$[$0-1].value.length == 2) {
				  	contador++;
					var id;
					if($$[$0-1].hasOwnProperty("varlast")) {
						id = ast.Leaf(contador,$$[$0-2]);
						id = [id,$$[$0-1].varlast];
						console.log(id)
					} else {
			  			id = ast.Leaf(contador,$$[$0-2]);
					}
					contador++;
					r = this.$ = ast.Node(contador,$$[$0-1].value[0],id,$$[$0-1].value[1]);
			  } else {
				  contador++;
					var id;
					if($$[$0-1].hasOwnProperty("varlast")) {
						id = ast.Leaf(contador,$$[$0-2]);
						id = [id,$$[$0-1].varlast];
						console.log(id)
					} else {
			  			id = ast.Leaf(contador,$$[$0-2]);
					}
					contador++;
					r = this.$ = ast.Node(contador,$$[$0-1].value[0],id,null);
			  
			  }
			 this.$ = r;
		  
break;
case 70:

			var r;
			  if($$[$0].value.length == 2) {
				  	contador++;
					var id;
					if($$[$0].hasOwnProperty("varlast")) {
						id = ast.Leaf(contador,$$[$0-1]);
						id = [id,$$[$0].varlast];
						console.log(id)
					} else {
			  			id = ast.Leaf(contador,$$[$0-1]);
					}
					contador++;
					r = ast.Node(contador,$$[$0].value[0],id,$$[$0].value[1]);
			  } else {
				  contador++;
					var id;
					if($$[$0].hasOwnProperty("varlast")) {
						id = ast.Leaf(contador,$$[$0-1]);
						id = [id,$$[$0].varlast];
						console.log(id)
					} else {
			  			id = ast.Leaf(contador,$$[$0-1]);
					}
					contador++;
					r = this.$ = ast.Node(contador,$$[$0].value[0],id,null);
			  
			  }
			 this.$ = r;
		  
break;
case 71:

				$$[$0].varlast = $$[$0-1];
				this.$ = $$[$0];
			
break;
case 72:

			this.$ =$$[$0];
		 
break;
case 73:
 
			contador++;
			var p1 = ast.Leaf(contador,"corchete Abre");
			contador++;
			var p2 = ast.Leaf(contador,"corchete cierra");
			contador++;
			this.$ = ast.Node(contador,"varLast",[p1,$$[$0-2],p2],$$[$0])
			
		
break;
case 74:
 
			contador++;
			var pi = ast.Leaf(contador,$$[$0-2]+$$[$0-1]);
			contador++;
			this.$ = ast.Node(contador,"varLast",pi,$$[$0])
		
break;
case 75:
 this.$ = $$[$0];
break;
case 76:
 this.$ = null;
break;
case 77: case 78: case 79: case 80: case 81:
	
				this.$ = {value:[$$[$0-1],$$[$0]]}
			
break;
case 82: case 83:

				this.$={value:[$$[$0]]}
			
break;
case 86:

			contador++;
			this.$ = ast.Node(contador,"ListType",$$[$0-2],$$[$0]);
		
break;
case 87:
this.$ =$$[$0];
break;
case 90:

			contador++;
			var id = ast.Leaf(contador,$$[$0-2]);
			contador++;
			var types = ast.Leaf(contador,$$[$0]);
			contador++;
			this.$ = ast.Node(contador,"KeyValue",id,types);
		
break;
case 93:

			this.$ = {value:$$[$0],type:$$[$0-2]}
		
break;
case 94:
 
			this.$ = {value:$$[$0]}
		
break;
case 96: case 98: case 100:

		   this.$ = $$[$0] + $$[$0-1];
	   
break;
case 97:

		   this.$ = $$[$0] + $$[$0-1];
	  
break;
case 99:

		  this.$ = $$[$0] + $$[$0-1];
	   
break;
case 101:
 this.$ = "arreglo de dimension " + $$[$0]+ " " ; 
break;
case 102:
 this.$ = ""; 
break;
case 103:

			this.$ = $$[$0-2] + 1;
		
break;
case 104:

			this.$ = 1;
		
break;
case 105:

			contador++;
			this.$ =  ast.Node(contador,"E",$$[$0],null);
		
break;
case 106:

		contador++;
		var curlyO = ast.Leaf(contador,"\"{\"");
		contador++;
		var curlyC = ast.Leaf(contador,"\"}\"");
		var arr = []
		arr.push(curlyO)
		if($$[$0-1] != null) {
			arr.push($$[$0-1])
		}
		arr.push(curlyC)
		contador++;
		var obj = ast.Node(contador,"OBJETO",arr,null);
		contador++;
		this.$ = ast.Node(contador,"E",obj,null)
	
break;
case 107:
 
		contador++;
		var e =  ast.Node(contador,"+",$$[$0-2],$$[$0]);
		contador++;
		this.$ = ast.Node(contador,"exp",e,null)
	
break;
case 108:
 
		contador++;
		var e =  ast.Node(contador,"-",$$[$0-2],$$[$0]);
		contador++;
		this.$ = ast.Node(contador,"exp",e,null)
	
break;
case 109:
 
		contador++;
		var e =  ast.Node(contador,"*",$$[$0-2],$$[$0]);
		contador++;
		this.$ = ast.Node(contador,"exp",e,null)
	
break;
case 110:
 
		contador++;
		var e =  ast.Node(contador,"/",$$[$0-2],$$[$0]);
		contador++;
		this.$ = ast.Node(contador,"exp",e,null)
	
break;
case 111:

		contador++;
		var e =  ast.Node(contador,"'-''",$$[$0],null);
		contador++;
		this.$ = ast.Node(contador,"exp",e,null)
	
break;
case 112:
 
		contador++;
		var e =  ast.Node(contador,"**",$$[$0-2],$$[$0]);
		contador++;
		this.$ = ast.Node(contador,"exp",e,null)
	
break;
case 113:
 
		contador++;
		var e =  ast.Node(contador,"%",$$[$0-2],$$[$0]);
		contador++;
		this.$ = ast.Node(contador,"exp",e,null)
	
break;
case 114:
 
		contador++;
		var e =  ast.Node(contador,">",$$[$0-2],$$[$0]);
		contador++;
		this.$ = ast.Node(contador,"exp",e,null)
	
break;
case 115:
 
		contador++;
		var e =  ast.Node(contador,"<",$$[$0-2],$$[$0]);
		contador++;
		this.$ = ast.Node(contador,"exp",e,null)
	
break;
case 116:
 
		contador++;
		var e =  ast.Node(contador,">=",$$[$0-2],$$[$0]);
		contador++;
		this.$ = ast.Node(contador,"exp",e,null)
	
break;
case 117:
 
		contador++;
		var e =  ast.Node(contador,"<=",$$[$0-2],$$[$0]);
		contador++;
		this.$ = ast.Node(contador,"exp",e,null)
	
break;
case 118:
 
		contador++;
		var e =  ast.Node(contador,"==",$$[$0-2],$$[$0]);
		contador++;
		this.$ = ast.Node(contador,"exp",e,null)
	
break;
case 119:
 
		contador++;
		var e =  ast.Node(contador,"!=",$$[$0-2],$$[$0]);
		contador++;
		this.$ = ast.Node(contador,"exp",e,null)
	
break;
case 120:
 
		contador++;
		var e =  ast.Node(contador,"&&",$$[$0-2],$$[$0]);
		contador++;
		this.$ = ast.Node(contador,"exp",e,null)
	
break;
case 121:
 
		contador++;
		var e =  ast.Node(contador,"||",$$[$0-2],$$[$0]);
		contador++;
		this.$ = ast.Node(contador,"exp",e,null)
	
break;
case 122:
 
		contador++;
		var e =  ast.Node(contador,"!",$$[$0],null);
		contador++;
		this.$ = ast.Node(contador,"exp",e,null)
	
break;
case 123:

		contador++;
		parA = ast.Leaf(contador,"Parentesis Abre")
		contador++;
		parC = ast.Leaf(contador,"Parentesis Cierra")
		contador++;
		this.$ = ast.Node(contador,"exp",[parA,$$[$0-1],parC],null)
	
break;
case 124:
	
		contador++;
		var e1 = ast.Node(contador,"?",$$[$0-2],null);
		contador++;
		var e2 = ast.Node(contador,":",$$[$0],null);
		contador++;
		this.$ = ast.Node(contador,"OperadorTernario",[$$[$0-4],e1,e2],null)
	
break;
case 125:

		contador++;
		var inc = ast.Node(contador,"++",$$[$0-1],null)
		contador++;
		this.$ = ast.Node(contador,"exp",inc,null)
	
break;
case 126:

		contador++;
		var dec = ast.Node(contador,"--",$$[$0-1],null)
		contador++;
		this.$ = ast.Node(contador,"exp",dec,null)
	
break;
case 127: case 128: case 134:
 
		contador++;
		this.$ = ast.Leaf(contador,$$[$0]);
	
break;
case 129:
 
		contador++;
		this.$ = ast.Leaf(contador,"true");
	
break;
case 130:
 
		contador++;
		this.$ = ast.Leaf(contador,"false");
	
break;
case 131:
 
		contador++;
		this.$ = ast.Leaf(contador,"null");
	
break;
case 132:
 
		contador++;
		this.$ = ast.Leaf(contador,"undefined");
	
break;
case 133:

		contador++;
		var id = ast.Leaf(contador,$$[$0-1]);
		contador++;
		this.$ = ast.Node(contador,"exp",id,$$[$0])
	
break;
case 135:

		contador++;
		var id = ast.Leaf(contador,$$[$0-4]);
		contador++;
		var bkOp = ast.Leaf(contador,"ParentesisAbre")
		contador++;
		var bkC = ast.Leaf(contador,"ParentesisCierra")
		var arr = [];
		arr.push(id)
		if($$[$0-3]!=null) {
			arr.push($$[$0-3])
		}
		arr.push(bkOp)
		if($$[$0-1]) {
			arr.push($$[$0-1])
		}
		arr.push(bkC)
		contador++;
		this.$ = ast.Node(contador,"LlamadaFuncion",arr,null);
		

	
break;
case 136:

		contador++;
		var sqBO = ast.Leaf(contador,"corcheteA")
		contador++;
		var sqBC = ast.Leaf(contador,"corcheteC")
		contador++;
		var arr = [];
		arr.push(sqBO)
		if($$[$0-1] != null) {
			arr.push($$[$0-1])
		}
		arr.push(sqBC)
		this.$ = ast.Node(contador,"exp",arr,null)
	
break;
case 139:

				   contador++;
				   var comma = ast.Leaf(contador,",");
				   
				   contador++;
				   this.$ = ast.Node(contador,"ListaArreglos",[$$[$0-2],comma,$$[$0]],null)
			   
break;
case 140:
this.$=$$[$0]; 
break;
case 142:
this.$= null;
break;
case 143:

					contador++;
					this.$ = ast.Node(contador,"ListaObjeto",$$[$0-2],$$[$0]);
				
break;
case 144:
 this.$ =$$[$0]; 
break;
case 145:

		contador++;
		var id = ast.Leaf(contador,$$[$0-2])
		contador++;
		this.$ = ast.Node(contador,"KeyValue",id,$$[$0])
	
break;
}
},
table: [{3:1,4:2,6:3,7:4,8:5,9:$V0,10:$V1,16:7,17:8,18:9,19:10,20:11,21:12,30:$V2,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},{1:[3]},{5:[1,23],6:24,7:4,8:5,9:$V0,10:$V1,16:7,17:8,18:9,19:10,20:11,21:12,30:$V2,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},o($Va,[2,3]),o($Va,[2,4]),o($Va,[2,5]),{10:[1,25]},o($Va,[2,7]),o($Va,[2,8]),o($Va,[2,9]),o($Va,[2,10]),o($Va,[2,11]),o($Va,[2,12]),{11:$Vb,22:26,23:$Vc,26:28,59:27,67:29,68:$Vd,71:$Ve,72:$Vf,73:$Vg,74:$Vh,75:$Vi,76:$Vj,77:$Vk},{10:[1,39]},{10:[1,40]},{23:[1,41]},{23:[1,42]},{12:[1,43]},{23:[1,44]},{23:[1,45]},{10:[2,91]},{10:[2,92]},{1:[2,1]},o($Va,[2,2]),{11:[1,46]},{23:[1,47]},o($Vl,[2,70],{15:[1,48]}),{11:$Vb,23:$Vm,67:49,72:$Vf,73:$Vg,74:$Vh,75:$Vi,76:$Vj,77:$Vk},o($Vn,[2,72]),{10:$Vo,23:$Vp,43:50,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:[1,62]},{10:$Vo,12:$Vz,23:$Vp,29:63,43:64,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:$Vo,12:$Vz,23:$Vp,29:66,43:64,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:$Vo,12:$Vz,23:$Vp,29:67,43:64,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:$Vo,12:$Vz,23:$Vp,29:68,43:64,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:$Vo,12:$Vz,23:$Vp,29:69,43:64,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},o($Vn,[2,82]),o($Vn,[2,83]),o($VA,$VB,{65:70,11:$VC,33:$VD}),{23:[1,73]},{10:$Vo,23:$Vp,43:74,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:$Vo,23:$Vp,43:75,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{7:78,8:79,10:$V1,17:80,18:81,19:82,20:83,21:84,35:76,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},{10:$Vo,23:$Vp,43:88,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:$Vo,23:$Vp,43:90,58:[1,89],68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:[1,91]},{10:$Vo,12:$Vz,23:$Vp,24:92,25:$VH,27:93,29:94,43:64,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},o($Vl,[2,69]),o($Vn,[2,71]),{69:[1,95],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{10:$Vo,23:$Vp,43:113,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:$Vo,23:$Vp,43:114,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:$Vo,23:$Vp,43:115,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},o($VZ,[2,127]),o($VZ,[2,128]),o($VZ,[2,129]),o($VZ,[2,130]),o($VZ,[2,131]),o($VZ,[2,132]),o($VZ,[2,134],{26:116,22:117,23:$Vc,68:$Vd,71:$Ve}),{10:$Vo,12:$Vz,23:$Vp,29:120,43:64,68:$Vq,69:[2,138],90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy,111:118,112:119},o($V_,$V$,{70:121,26:122,68:$Vd,71:$Ve}),o($Vn,[2,77]),o($V01,[2,105],{76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY}),{10:$V11,14:[2,142],88:123,113:124,114:125},o($Vn,[2,78]),o($Vn,[2,79]),o($Vn,[2,80]),o($Vn,[2,81]),{15:[2,65],28:[1,128],63:127},{10:$V21,34:129,82:$V31,84:$V41,85:$V51,86:$V61},{10:$Vo,12:$Vz,23:$Vp,29:135,43:64,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:[1,138],25:[2,24],31:136,36:137},{25:[1,139],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{25:[1,140],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{7:78,8:79,10:$V1,14:[1,141],17:80,18:81,19:82,20:83,21:84,37:142,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},o($V71,[2,28]),o($V71,[2,29]),o($V71,[2,30]),o($V71,[2,31]),o($V71,[2,32]),o($V71,[2,33]),o($V71,[2,34]),o($V71,[2,35]),{15:[1,143]},{15:[1,144]},{10:$Vo,12:$Vz,15:[1,147],23:$Vp,29:146,41:145,43:64,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{25:[1,148],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{10:[1,149]},{11:[1,150],15:[1,151],60:152,61:$V81,62:$V91,76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{10:$Va1,13:155,14:[2,85],78:156,80:157},{25:[1,159]},{25:[2,16],28:[1,160]},o($Vb1,[2,19]),o($V_,$V$,{26:122,70:161,68:$Vd,71:$Ve}),{10:$Vo,23:$Vp,43:162,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:$Vo,23:$Vp,43:163,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:$Vo,23:$Vp,43:164,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:$Vo,23:$Vp,43:165,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:$Vo,23:$Vp,43:166,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:$Vo,23:$Vp,43:167,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:$Vo,23:$Vp,43:168,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:$Vo,23:$Vp,43:169,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:$Vo,23:$Vp,43:170,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:$Vo,23:$Vp,43:171,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:$Vo,23:$Vp,43:172,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:$Vo,23:$Vp,43:173,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:$Vo,23:$Vp,43:174,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:$Vo,23:$Vp,43:175,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:$Vo,23:$Vp,43:176,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},o($VZ,[2,125]),o($VZ,[2,126]),o($VZ,[2,111]),o($VZ,[2,122]),{25:[1,177],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},o($VZ,[2,133],{23:$Vm}),{23:[1,178]},{69:[1,179]},{28:[1,180],69:[2,137]},o($Vc1,[2,140]),o($V_,[2,74]),o($V_,[2,75]),{14:[1,181]},{14:[2,141],15:$Vd1,28:$Ve1,79:182},o($Vf1,[2,144]),{33:[1,185]},{15:[1,186]},{10:[1,188],64:187},{11:[1,189]},o($Vg1,$Vh1,{83:190,87:191,68:$Vi1}),o($Vg1,$Vh1,{87:191,83:193,68:$Vi1}),o($Vg1,$Vh1,{87:191,83:194,68:$Vi1}),o($Vg1,$Vh1,{87:191,83:195,68:$Vi1}),o($Vg1,$Vh1,{87:191,83:196,68:$Vi1}),o($VA,[2,94]),{25:[1,197]},{25:[2,23],28:[1,198]},{33:[1,199]},{12:[1,200]},{12:[1,201]},{47:[1,202]},o($V71,[2,27]),o($V71,[2,36]),o($V71,[2,37]),o($V71,[2,38]),{15:[1,203]},o($V71,[2,40]),{12:[1,204]},{11:[1,205],60:206,61:$V81,62:$V91},{10:$Vo,23:$Vp,43:207,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:$Vo,23:$Vp,43:208,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:$Vo,23:$Vp,43:209,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},o($Vj1,[2,62]),o($Vj1,[2,63]),{14:[1,210]},{14:[2,84],15:$Vd1,28:$Ve1,79:211},o($Vf1,[2,87]),{33:[1,212]},{15:[1,213]},{10:$Vo,12:$Vz,23:$Vp,29:214,43:64,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},o($V_,[2,73]),o($Vk1,[2,107],{76:$VI,77:$VJ,91:$VM,92:$VN,93:$VO,94:$VP}),o($Vk1,[2,108],{76:$VI,77:$VJ,91:$VM,92:$VN,93:$VO,94:$VP}),o($Vl1,[2,109],{76:$VI,77:$VJ,93:$VO}),o($Vl1,[2,110],{76:$VI,77:$VJ,93:$VO}),o($VZ,[2,112]),o($Vl1,[2,113],{76:$VI,77:$VJ,93:$VO}),o($Vm1,[2,114],{76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP}),o($Vm1,[2,115],{76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP}),o($Vm1,[2,116],{76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP}),o($Vm1,[2,117],{76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP}),o($Vm1,[2,118],{76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP}),o($Vm1,[2,119],{76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP}),o([5,9,10,11,14,15,25,28,30,33,38,39,40,42,47,48,49,53,56,57,58,61,62,69,81,101,102,104],[2,120],{76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV}),o([5,9,10,11,14,15,25,28,30,33,38,39,40,42,47,48,49,53,56,57,58,61,62,69,81,102,104],[2,121],{76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW}),{33:[1,215],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},o($VZ,[2,123]),{10:$Vo,12:$Vz,23:$Vp,24:216,25:$VH,27:93,29:94,43:64,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},o($VZ,[2,136]),{10:$Vo,12:$Vz,23:$Vp,29:217,43:64,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},o($V01,[2,106]),{10:$V11,114:218},{10:[2,88]},{10:[2,89]},{10:$Vo,12:$Vz,23:$Vp,29:219,43:64,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},o($Vl,[2,68]),{15:[2,64],28:[1,220]},o($VA,$VB,{65:221,11:$VC,33:$VD}),{10:$Vo,12:$Vz,23:$Vp,29:222,43:64,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},o($Vg1,[2,96]),o($Vg1,[2,101],{68:[1,223]}),{69:[1,224]},o($Vg1,[2,97]),o($Vg1,[2,98]),o($Vg1,[2,99]),o($Vg1,[2,100]),{12:[1,227],32:225,33:[1,226]},{10:[1,228]},{10:$V21,34:229,82:$V31,84:$V41,85:$V51,86:$V61},{7:78,8:79,10:$V1,17:80,18:81,19:82,20:83,21:84,35:230,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},{7:78,8:79,10:$V1,17:80,18:81,19:82,20:83,21:84,35:231,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},{23:[1,232]},o($V71,[2,39]),{50:233,52:234,53:$Vn1,56:[2,50]},{10:$Vo,23:$Vp,43:236,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:$Vo,23:$Vp,43:237,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{15:[1,238],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{15:[1,239],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{25:[1,240],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{15:[1,241]},{10:$Va1,80:242},{10:$V21,34:243,82:$V31,84:$V41,85:$V51,86:$V61},o($Vl,[2,13]),o($Vb1,[2,18]),{10:$Vo,23:$Vp,43:244,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{25:[1,245]},o($Vc1,[2,139]),o($Vf1,[2,143]),o($Vf1,[2,145]),{10:[1,246]},o($VA,[2,67]),o($VA,[2,93]),{69:[1,247]},o($Vo1,[2,104]),o($Va,[2,20]),{10:$V21,34:248,82:$V31,84:$V41,85:$V51,86:$V61},{7:78,8:79,10:$V1,17:80,18:81,19:82,20:83,21:84,35:249,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},{33:[1,250]},o($Vb1,[2,26]),{7:78,8:79,10:$V1,14:[1,251],17:80,18:81,19:82,20:83,21:84,37:142,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},{7:78,8:79,10:$V1,14:[1,252],17:80,18:81,19:82,20:83,21:84,37:142,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},{10:$Vo,23:$Vp,43:253,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{51:254,54:255,56:[1,256]},{53:$Vp1,56:[2,49]},{10:$Vo,23:$Vp,43:258,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{15:[1,259],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{25:[1,260],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{10:$Vo,23:$Vp,43:261,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{10:[1,262]},{12:[1,263]},o($Va,[2,6]),o($Vf1,[2,86]),o($Vf1,[2,90]),o([5,9,10,11,14,15,25,28,30,33,38,39,40,42,47,48,49,53,56,57,58,61,62,69,81],[2,124],{76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY}),o($VZ,[2,135]),o($VA,$VB,{65:264,11:$VC,33:$VD}),o($Vo1,[2,103]),{12:[1,265]},{7:78,8:79,10:$V1,14:[1,266],17:80,18:81,19:82,20:83,21:84,37:142,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},{10:$V21,34:267,82:$V31,84:$V41,85:$V51,86:$V61},o($Vl,$Vq1,{44:268,45:$Vr1}),o($Vl,[2,46]),{25:[1,270],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{14:[1,271]},{14:[2,56],52:273,53:$Vn1,55:272},{33:[1,274]},{10:$Vo,23:$Vp,43:275,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{33:[1,276],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{10:$Vo,23:$Vp,43:277,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:[1,278]},{15:[1,279],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{11:$Vb,26:281,59:280,67:29,68:$Vd,71:$Ve,72:$Vf,73:$Vg,74:$Vh,75:$Vi,76:$Vj,77:$Vk},{7:78,8:79,10:$V1,17:80,18:81,19:82,20:83,21:84,35:282,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},o($VA,[2,66]),{7:78,8:79,10:$V1,17:80,18:81,19:82,20:83,21:84,35:283,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},o($Va,[2,22]),o($Vb1,[2,25]),o($Vl,[2,41]),{12:[1,286],42:[1,285],46:284},{15:[1,287]},o($Vl,[2,48]),{14:[2,53]},{14:[2,55],53:$Vp1},{7:78,8:79,10:$V1,17:80,18:81,19:82,20:83,21:84,35:288,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},{33:[1,289],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{7:78,8:79,10:$V1,17:80,18:81,19:82,20:83,21:84,35:290,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},{15:[1,291],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{7:78,8:79,10:$V1,17:80,18:81,19:82,20:83,21:84,35:292,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},{10:[1,293]},{25:[1,294]},{11:$Vb,67:49,72:$Vf,73:$Vg,74:$Vh,75:$Vi,76:$Vj,77:$Vk},{7:78,8:79,10:$V1,14:[1,295],17:80,18:81,19:82,20:83,21:84,37:142,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},{7:78,8:79,10:$V1,14:[1,296],17:80,18:81,19:82,20:83,21:84,37:142,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},o($Vl,[2,42]),{23:[1,297]},{7:78,8:79,10:$V1,17:80,18:81,19:82,20:83,21:84,35:298,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},o($Vl,[2,47]),o([14,53],[2,54],{66:14,7:78,8:79,17:80,18:81,19:82,20:83,21:84,37:142,10:$V1,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,81:$V9}),{7:78,8:79,10:$V1,17:80,18:81,19:82,20:83,21:84,35:299,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},o($Vs1,[2,52],{66:14,7:78,8:79,17:80,18:81,19:82,20:83,21:84,37:142,10:$V1,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,81:$V9}),{10:[1,300]},{7:78,8:79,10:$V1,14:[1,301],17:80,18:81,19:82,20:83,21:84,37:142,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},{11:$Vb,26:281,59:302,67:29,68:$Vd,71:$Ve,72:$Vf,73:$Vg,74:$Vh,75:$Vi,76:$Vj,77:$Vk},{12:[1,303]},o($Vl,[2,61]),o($Va,[2,21]),{10:$Vo,23:$Vp,43:304,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{7:78,8:79,10:$V1,14:[1,305],17:80,18:81,19:82,20:83,21:84,37:142,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},o($Vs1,[2,51],{66:14,7:78,8:79,17:80,18:81,19:82,20:83,21:84,37:142,10:$V1,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,81:$V9}),{11:$Vb,26:281,59:306,67:29,68:$Vd,71:$Ve,72:$Vf,73:$Vg,74:$Vh,75:$Vi,76:$Vj,77:$Vk},o($Vl,[2,60]),{25:[1,307]},{7:78,8:79,10:$V1,17:80,18:81,19:82,20:83,21:84,35:308,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},{25:[1,309],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},o($Vl,[2,45]),{25:[1,310]},{12:[1,311]},{7:78,8:79,10:$V1,14:[1,312],17:80,18:81,19:82,20:83,21:84,37:142,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},{12:[1,313]},{12:[1,314]},{7:78,8:79,10:$V1,17:80,18:81,19:82,20:83,21:84,35:315,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},o($Vl,[2,59]),{7:78,8:79,10:$V1,17:80,18:81,19:82,20:83,21:84,35:316,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},{7:78,8:79,10:$V1,17:80,18:81,19:82,20:83,21:84,35:317,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},{7:78,8:79,10:$V1,14:[1,318],17:80,18:81,19:82,20:83,21:84,37:142,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},{7:78,8:79,10:$V1,14:[1,319],17:80,18:81,19:82,20:83,21:84,37:142,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},{7:78,8:79,10:$V1,14:[1,320],17:80,18:81,19:82,20:83,21:84,37:142,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,81:$V9},o($Vl,[2,58]),o($Vl,$Vq1,{44:321,45:$Vr1}),o($Vl,[2,57]),o($Vl,[2,44])],
defaultActions: {21:[2,91],22:[2,92],23:[2,1],183:[2,88],184:[2,89],272:[2,53]},
parseError: function parseError (str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    _token_stack:
        var lex = function () {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        };
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};

	var contador = 0;

	
	const ast = require('./AST/AST.js');
	
/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function(match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex () {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin (condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState () {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules () {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState (n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState (condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {"case-sensitive":true},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0://Comentario Linea
break;
case 1://Comentaio Multilinea
break;
case 2:return 39;
break;
case 3:return 38;
break;
case 4:return 109;
break;
case 5:return 9;
break;
case 6:return 81;
break;
case 7:return 58;
break;
case 8:return 81;
break;
case 9:return 30;
break;
case 10:return 42;
break;
case 11:return 45;
break;
case 12:return 47;
break;
case 13:return 48;
break;
case 14:return 49;
break;
case 15:return 53;
break;
case 16:return 56;
break;
case 17:return 57;
break;
case 18:return 61;
break;
case 19:return 62;
break;
case 20:return 82;
break;
case 21:return 84;
break;
case 22:return 85;
break;
case 23:return 86;
break;
case 24:return 107;
break;
case 25:return 108;
break;
case 26:return 110;
break;
case 27:return 40;
break;
case 28:return 72;
break;
case 29:return 73;
break;
case 30:return 74;
break;
case 31:return 75;
break;
case 32:return 12;
break;
case 33:return 14;
break;
case 34:return 23;
break;
case 35:return 25;
break;
case 36:return 28;
break;
case 37:return 15;
break;
case 38:return 33;
break;
case 39:return 71;
break;
case 40:return 76;
break;
case 41:return 77;
break;
case 42:return 89;
break;
case 43:return 90;
break;
case 44:return 93;
break;
case 45:return 91;
break;
case 46:return 92;
break;
case 47:return 94;
break;
case 48:return 97;
break;
case 49:return 98;
break;
case 50:return 95;
break;
case 51:return 96;
break;
case 52:return 99;
break;
case 53:return 11;
break;
case 54:return 100;
break;
case 55:return 101;
break;
case 56:return 102;
break;
case 57:return 103;
break;
case 58:return 104;
break;
case 59:return 68;
break;
case 60:return 69;
break;
case 61:
break;
case 62:
break;
case 63:
break;
case 64:
break;
case 65:return 105;
break;
case 66:return 106;
break;
case 67:return 10;
break;
case 68:return 5;
break;
case 69: console.error('Este es un error léxico: ' + yy_.yytext + ', en la linea: ' + yy_.yylloc.first_line + ', en la columna: ' + yy_.yylloc.first_column); 
break;
}
},
rules: [/^(?:\/\/.*)/,/^(?:[\/][*][^*]*[*]+([^\/*][^*]*[*]+)*[\/])/,/^(?:continue\b)/,/^(?:break\b)/,/^(?:null\b)/,/^(?:type\b)/,/^(?:const\b)/,/^(?:let\b)/,/^(?:const\b)/,/^(?:function\b)/,/^(?:if\b)/,/^(?:else\b)/,/^(?:while\b)/,/^(?:do\b)/,/^(?:switch\b)/,/^(?:case\b)/,/^(?:default\b)/,/^(?:for\b)/,/^(?:in\b)/,/^(?:of\b)/,/^(?:number\b)/,/^(?:boolean\b)/,/^(?:string\b)/,/^(?:void\b)/,/^(?:true\b)/,/^(?:false\b)/,/^(?:undefined\b)/,/^(?:return\b)/,/^(?:\+=)/,/^(?:-=)/,/^(?:\*=)/,/^(?:\/=)/,/^(?:\{)/,/^(?:\})/,/^(?:\()/,/^(?:\))/,/^(?:,)/,/^(?:;)/,/^(?::)/,/^(?:\.)/,/^(?:\+\+)/,/^(?:--)/,/^(?:\+)/,/^(?:-)/,/^(?:\*\*)/,/^(?:\*)/,/^(?:\/)/,/^(?:%)/,/^(?:>=)/,/^(?:<=)/,/^(?:>)/,/^(?:<)/,/^(?:==)/,/^(?:=)/,/^(?:!=)/,/^(?:&&)/,/^(?:\|\|)/,/^(?:!)/,/^(?:\?)/,/^(?:\[)/,/^(?:\])/,/^(?:\s+)/,/^(?:\t+)/,/^(?:\r+)/,/^(?:\n+)/,/^(?:[0-9]+(\.[0-9]+)?\b)/,/^(?:"[^\"]*"|'[^\']*'|`[^\`]*`)/,/^(?:([a-zA-Z$_])[a-zA-Z0-9_$]*)/,/^(?:$)/,/^(?:.)/],
conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = AST;
exports.Parser = AST.Parser;
exports.parse = function () { return AST.parse.apply(AST, arguments); };
exports.main = function commonjsMain (args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
}
}).call(this,require('_process'))
},{"./AST/AST.js":2,"_process":112,"fs":107,"path":111}],2:[function(require,module,exports){

function Node(n,op,left,right){
    let str = "N"+n + "("+op+");";
    if(left != null && left != "") {
        if(Array.isArray(left)) {
            left.forEach(element=>{
                str += "\n";
                str += element.code + "\n";
                str += "N"+n + "-->" + "N" + element.count+";";
            });
        } else {
            str += "\n";
            str += left.code + "\n";
            str += "N"+n + "-->" + "N" + left.count+";";
        }
    }
    if(right != null && right != "") {
        
            str += "\n";
            str += right.code + "\n";
            str += "N"+n + "-->" + "N" + right.count+";";
        
    }
    return {code:str,count:n}
}

function Leaf(n,value){
    return {code:"N"+n + "("+value+");",count:n};
}




module.exports = {
    Leaf:Leaf,
    Node:Node
}
},{}],3:[function(require,module,exports){
const parser = require('./gramatica.js');
const Scope = require('./traductor/translateScope.js');

//let entrada;

function traducir(entrada) {

    let result = parser.parse(entrada.toString());
    var scopeT = new Scope(null);
    var scopeST = new Scope(null);
    var ast = result.ast;
    var a = "";
    var innerFunction = result.inner;
    var innerF = "";

    ast.forEach(element => {
        if(element.constructor.name == "tAsignVariables" || element.constructor.name == "declaracionTypes" ) {
            element.translate(scopeST,null,null,null);
        }
    });

    var usedVars = [];
    if(innerFunction.length != 0) {
        innerFunction.forEach(element => {
            innerF += element.func.translate(scopeST,element.parent,usedVars,null);
            //scopeST.varUse = [];
        });
    }

    ast.forEach(element => {
        if(!(element.constructor.name == "tAsignVariables" || element.constructor.name == "declaracionTypes")) {
            a += element.translate(scopeST,null,usedVars,null);
        }
        
    });

    var global = "";
    if(scopeST.table.length > 0) {
        scopeST.table.forEach(element => {
            global += element.varDec + " " + element.id + element.value+ ";\n";
        })
        global += "\n"
    }

    console.log("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$");
    var translateDoc = global + innerF + a;
    return translateDoc;
}


module.exports = traducir;

/*var auxEntrada = entrada.toString().replace(/\s/g, "");
var traducidoSinEsp = salida.toString().replace(/\s/g, "");
*/
//console.log("ES IGUAL: " + (auxEntrada == traducidoSinEsp));


},{"./gramatica.js":44,"./traductor/translateScope.js":101}],4:[function(require,module,exports){
(function (process){
/* parser generated by jison 0.4.18 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var ejecucion = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,7],$V1=[1,14],$V2=[1,16],$V3=[1,17],$V4=[1,18],$V5=[1,19],$V6=[1,20],$V7=[1,21],$V8=[1,22],$V9=[1,23],$Va=[5,11,12,30,42,47,48,49,57,58,81],$Vb=[1,35],$Vc=[2,17],$Vd=[1,33],$Ve=[1,34],$Vf=[1,36],$Vg=[1,37],$Vh=[1,38],$Vi=[1,39],$Vj=[1,40],$Vk=[1,41],$Vl=[5,8,11,12,30,38,39,40,42,47,48,49,53,56,57,58,81],$Vm=[2,16],$Vn=[5,7,8,11,12,25,30,38,39,40,42,47,48,49,53,56,57,58,81],$Vo=[1,63],$Vp=[1,56],$Vq=[1,64],$Vr=[1,54],$Vs=[1,55],$Vt=[1,57],$Vu=[1,58],$Vv=[1,59],$Vw=[1,60],$Vx=[1,61],$Vy=[1,62],$Vz=[1,68],$VA=[7,28],$VB=[2,97],$VC=[1,75],$VD=[1,74],$VE=[1,88],$VF=[1,89],$VG=[1,90],$VH=[2,19],$VI=[1,114],$VJ=[1,115],$VK=[1,99],$VL=[1,100],$VM=[1,101],$VN=[1,102],$VO=[1,103],$VP=[1,104],$VQ=[1,105],$VR=[1,106],$VS=[1,107],$VT=[1,108],$VU=[1,109],$VV=[1,110],$VW=[1,111],$VX=[1,112],$VY=[1,113],$VZ=[5,7,8,11,12,13,25,28,30,33,38,39,40,42,47,48,49,53,56,57,58,61,62,69,76,77,81,89,90,91,92,93,94,95,96,97,98,99,100,101,102,104],$V_=[5,7,8,11,12,13,23,25,28,30,33,38,39,40,42,47,48,49,53,56,57,58,61,62,69,72,73,74,75,76,77,81,89,90,91,92,93,94,95,96,97,98,99,100,101,102,104],$V$=[2,78],$V01=[5,7,8,11,12,25,28,30,38,39,40,42,47,48,49,53,56,57,58,69,81],$V11=[1,129],$V21=[1,137],$V31=[1,133],$V41=[1,134],$V51=[1,135],$V61=[1,136],$V71=[8,12,38,39,40,42,47,48,49,53,56,57,58,81],$V81=[1,156],$V91=[1,157],$Va1=[1,161],$Vb1=[25,28],$Vc1=[28,69],$Vd1=[1,187],$Ve1=[1,186],$Vf1=[7,8,28],$Vg1=[7,8,13,14,25,28],$Vh1=[2,104],$Vi1=[1,195],$Vj1=[12,23,68,90,103,105,106,107,108,109,110],$Vk1=[5,7,8,11,12,13,25,28,30,33,38,39,40,42,47,48,49,53,56,57,58,61,62,69,81,89,90,95,96,97,98,99,100,101,102,104],$Vl1=[5,7,8,11,12,13,25,28,30,33,38,39,40,42,47,48,49,53,56,57,58,61,62,69,81,89,90,91,92,94,95,96,97,98,99,100,101,102,104],$Vm1=[5,7,8,11,12,13,25,28,30,33,38,39,40,42,47,48,49,53,56,57,58,61,62,69,81,95,96,97,98,99,100,101,102,104],$Vn1=[1,238],$Vo1=[7,8,13,14,25,28,68],$Vp1=[1,260],$Vq1=[2,45],$Vr1=[1,272],$Vs1=[8,53,56];
var parser = {trace: function trace () { },
yy: {},
symbols_: {"error":2,"S":3,"Bloque":4,"EOF":5,"Instruccion":6,"semicolon":7,"curlyBraceClose":8,"llamadaFuncion":9,"variables":10,"Type":11,"id":12,"igual":13,"curlyBraceOpen":14,"parsObj":15,"funciones":16,"IF":17,"WHILE":18,"DOWHILE":19,"SWITCH":20,"FOR":21,"PL":22,"bracketOpen":23,"paramFunc":24,"bracketClose":25,"varLast":26,"paramFuncList":27,"comma":28,"E":29,"function":30,"funcParam":31,"funcDec":32,"dosPuntos":33,"types":34,"STMT":35,"funcParamList":36,"InstruccionI":37,"Break":38,"Continue":39,"return":40,"OP":41,"if":42,"exp":43,"IFLAST":44,"else":45,"IFCOND":46,"while":47,"do":48,"switch":49,"FIRSTCASE":50,"LASTCASE":51,"CASE":52,"case":53,"DEFCASE":54,"ENDCASE":55,"default":56,"for":57,"let":58,"asignLast":59,"forOP":60,"in":61,"of":62,"defVarLast":63,"defVarLastP":64,"defLast":65,"defType":66,"asignLastF":67,"sqBracketOpen":68,"sqBracketClose":69,"auxP":70,"point":71,"masIgual":72,"menosIgual":73,"porIgual":74,"divisionIgual":75,"increment":76,"decrement":77,"objType":78,"opkv":79,"keyvalueT":80,"const":81,"number":82,"typesList":83,"boolean":84,"string":85,"void":86,"typesL":87,"objetoParam":88,"mas":89,"menos":90,"por":91,"division":92,"potencia":93,"modulo":94,"mayorque":95,"menorque":96,"mayorigualque":97,"menorigualque":98,"igualdad":99,"diferencia":100,"and":101,"or":102,"not":103,"question":104,"NUMBER":105,"STRING":106,"true":107,"false":108,"null":109,"undefined":110,"arrParam":111,"listArrParam":112,"objetoParamList":113,"keyvalue":114,"$accept":0,"$end":1},
terminals_: {2:"error",5:"EOF",7:"semicolon",8:"curlyBraceClose",11:"Type",12:"id",13:"igual",14:"curlyBraceOpen",23:"bracketOpen",25:"bracketClose",28:"comma",30:"function",33:"dosPuntos",38:"Break",39:"Continue",40:"return",42:"if",45:"else",47:"while",48:"do",49:"switch",53:"case",56:"default",57:"for",58:"let",61:"in",62:"of",68:"sqBracketOpen",69:"sqBracketClose",71:"point",72:"masIgual",73:"menosIgual",74:"porIgual",75:"divisionIgual",76:"increment",77:"decrement",81:"const",82:"number",84:"boolean",85:"string",86:"void",89:"mas",90:"menos",91:"por",92:"division",93:"potencia",94:"modulo",95:"mayorque",96:"menorque",97:"mayorigualque",98:"menorigualque",99:"igualdad",100:"diferencia",101:"and",102:"or",103:"not",104:"question",105:"NUMBER",106:"STRING",107:"true",108:"false",109:"null",110:"undefined"},
productions_: [0,[3,2],[4,2],[4,1],[4,2],[4,2],[6,1],[6,1],[6,7],[6,1],[6,1],[6,1],[6,1],[6,1],[6,1],[9,6],[22,1],[22,0],[24,1],[24,0],[27,3],[27,1],[16,6],[32,5],[32,3],[31,1],[31,0],[36,5],[36,3],[35,2],[35,1],[37,1],[37,1],[37,1],[37,1],[37,1],[37,1],[37,1],[37,2],[37,2],[37,2],[41,2],[41,1],[17,8],[44,2],[44,0],[46,8],[46,3],[18,7],[19,9],[20,8],[50,1],[50,0],[52,5],[52,4],[51,2],[54,3],[55,1],[55,0],[21,15],[21,14],[21,12],[21,10],[21,9],[60,1],[60,1],[63,2],[63,0],[64,4],[64,2],[10,5],[10,3],[10,2],[59,2],[59,1],[26,4],[26,3],[70,1],[70,0],[67,2],[67,2],[67,2],[67,2],[67,2],[67,1],[67,1],[15,1],[15,0],[78,3],[78,1],[79,1],[79,1],[80,3],[66,1],[66,1],[65,4],[65,2],[65,0],[34,2],[34,2],[34,2],[34,2],[34,2],[83,1],[83,0],[87,3],[87,2],[29,1],[29,3],[43,3],[43,3],[43,3],[43,3],[43,2],[43,3],[43,3],[43,3],[43,3],[43,3],[43,3],[43,3],[43,3],[43,3],[43,3],[43,2],[43,3],[43,5],[43,2],[43,2],[43,1],[43,1],[43,1],[43,1],[43,1],[43,1],[43,2],[43,1],[43,5],[43,3],[111,1],[111,0],[112,3],[112,1],[88,1],[88,0],[113,3],[113,1],[114,3]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
 	console.log(tablaErrores)
	return {ast:$$[$0-1],tabla:tablaErrores}; 
break;
case 2: case 29:
 $$[$0-1].push($$[$0]); this.$=$$[$0-1];
break;
case 3: case 30:
 this.$ = [$$[$0]]; 
break;
case 4:

	tablaErrores.push({line:_$[$0-1].first_line,column:_$[$0-1].first_column,type:'Semantico',msg:'El caracter: ' + yytext + " no se esperaba"})

break;
case 5:

	tablaErrores.push({line:_$[$0-1].first_line,column:_$[$0-1].first_column,type:'Semantico',msg:'El caracter: ' + yytext + " no se esperaba"})


break;
case 6: case 9: case 10: case 12: case 13: case 14: case 31: case 32: case 33: case 34: case 35: case 36: case 37:
 this.$=$$[$0]; 
break;
case 7: case 11: case 18:
 this.$=$$[$0];
break;
case 8:
 this.$=new decType($$[$0-5],$$[$0-2]); 
break;
case 15:
 this.$ = new callFunction(0,0,$$[$0-5],$$[$0-4],$$[$0-2]); 
break;
case 16:
this.$= $$[$0];
break;
case 17: case 87: case 140:
this.$ = null;
break;
case 19:
 this.$=null;
break;
case 20:
$$[$0-2].push($$[$0]); this.$=$$[$0-2];
break;
case 21:
this.$ = [$$[$0]];
break;
case 22:

			this.$ = new Function($$[$0-4],$$[$0-2],$$[$0]);

break;
case 23:

			var hasType = true;
			this.$ = new FuncDec(hasType,$$[$0-3],$$[$0-1]);
		 
break;
case 24:

			var hasType = false;
			this.$ = new FuncDec(hasType,null,$$[$0-1]);
		 
break;
case 25:
 this.$ =$$[$0];
break;
case 26:
 this.$ = []; 
break;
case 27:
$$[$0-4].push({id:$$[$0-2],types:$$[$0]}); this.$=$$[$0-4];
break;
case 28:
this.$ = [{id:$$[$0-2],types:$$[$0]}];
break;
case 38:
 this.$=new EscapeExp('BREAK',null); 
break;
case 39:
 this.$=new EscapeExp('CONTINUE',null); 
break;
case 40:
 this.$=new EscapeExp('RETURN',$$[$0]); 
break;
case 41:
 this.$ = $$[$0-1];
break;
case 42: case 45: case 52: case 58: case 97: case 104:
 this.$ = null; 
break;
case 43:
 
		this.$ = new IF($$[$0-5],$$[$0-2],$$[$0]);
	 
break;
case 44: case 57: case 64: case 65: case 93: case 94: case 103: case 107: case 139: case 143:
 this.$ = $$[$0]; 
break;
case 46:

		   this.$ = new IF($$[$0-5],$$[$0-2],$$[$0]);
	   
break;
case 47:

		   this.$ = new IF(null,$$[$0-1],null);
	   
break;
case 48:

			this.$ = new While($$[$0-4],$$[$0-1]);
		
break;
case 49:

			this.$ = new doWhile($$[$0-2],$$[$0-6]);
		
break;
case 50:

			this.$ = new Switch($$[$0-5],$$[$0-2],$$[$0-1]);
		
break;
case 51:
 this.$ = new Case($$[$0]); 
break;
case 53:

		$$[$0-4].push({exp:$$[$0-2],stmt:$$[$0]});
		this.$ = $$[$0-4];
	 
break;
case 54:

		this.$ = [{exp:$$[$0-2],stmt:$$[$0]}]
	 
break;
case 55:

		this.$ = $$[$0-1];
	
break;
case 56:

	this.$ = new Defcase($$[$0]);

break;
case 59:

		this.$ = new ForNormal($$[$0-11],$$[$0-9],$$[$0-7],new asignVariable($$[$0-5],$$[$0-4]),$$[$0-1]);
	
break;
case 60:

		this.$ = new ForTwo($$[$0-11],$$[$0-9],$$[$0-7],new asignVariable($$[$0-5],$$[$0-4]),$$[$0-1]);
	
break;
case 61:

		this.$ = new ForThree($$[$0-9],$$[$0-7],new asignVariable($$[$0-5],$$[$0-4]),$$[$0-1]);
	
break;
case 62:

		this.$ = new ForEach(true,$$[$0-6],$$[$0-5],$$[$0-4],$$[$0-1]);
	
break;
case 63:

		this.$ = new ForEach(false,$$[$0-6],$$[$0-5],$$[$0-4],$$[$0-1]);
	
break;
case 66:

				this.$ = new defVarLast($$[$0]);
			
break;
case 67:
this.$=null;
break;
case 68:

				this.$ = new defVarLastP(0,0,$$[$0-3],$$[$0-1],$$[$0]);
			
break;
case 69:

				this.$ = new defVarLastP(0,0,null,$$[$0-1],$$[$0]);
			
break;
case 70:
 this.$ = new Variable(0,0,$$[$0-4],$$[$0-3],$$[$0-2],$$[$0-1]); 
break;
case 71:

			  //comprobar si es const o let
			  this.$ = new asignVariable($$[$0-2],$$[$0-1]);
		  
break;
case 72:

			  //comprobar si es const o let
			  this.$ = new asignVariable($$[$0-1],$$[$0]);
		  
break;
case 73:

				this.$ =new asignLast($$[$0-1],$$[$0]);
			
break;
case 74:

			 this.$ = new asignLast(null,$$[$0]);
		 
break;
case 75:
 this.$ = new idList(true,$$[$0-2],$$[$0]);
break;
case 76:
 this.$ = new idList(false,$$[$0-1],$$[$0]);
break;
case 77:
 this.$ = $$[$0];
break;
case 78:
 this.$ = null;
break;
case 79:

	this.$ = new asignLastF(null,$$[$0]);

break;
case 80:

	this.$ = new asignLastF("+",$$[$0]);

break;
case 81:

	this.$ = new asignLastF("-",$$[$0]);

break;
case 82:

	this.$ = new asignLastF("*",$$[$0]);

break;
case 83:

	this.$ = new asignLastF("/",$$[$0]);

break;
case 84:

	this.$ = new asignLastF("+",null);

break;
case 85:

	this.$ = new asignLastF("-",null);

break;
case 86: case 90: case 91:
this.$ = $$[$0];
break;
case 88:
  this.$ = new objType($$[$0-2],$$[$0]); 
break;
case 89:
this.$ = new objType(null,$$[$0]);
break;
case 92:
 this.$ = new typeKeyValue($$[$0-2],$$[$0]); 
break;
case 95:

			this.$ = new defLast(0,0,$$[$0-2],$$[$0]);
		
break;
case 96:
 this.$ = new defLast(0,0,null,$$[$0]);
break;
case 98:

		   this.$ = new Type("NUMBER",$$[$0]);
	   
break;
case 99:

		   this.$ = new Type("BOOLEAN",$$[$0]);
	  
break;
case 100:

		   this.$ = new Type("STRING",$$[$0]);
	   
break;
case 101:

		   this.$ = new Type("VOID",$$[$0]);
	   
break;
case 102:

		   this.$ = new Type($$[$0-1],$$[$0]);
	   
break;
case 105:

			this.$ = new typeList(0,0,$$[$0-2]);
		
break;
case 106:

			this.$ = new typeList(0,0,null);
		
break;
case 108:

		this.$ = new Obj($$[$0-1]);
	
break;
case 109:
 this.$ = new Operation(0,0,$$[$0-2],$$[$0],"+"); 
break;
case 110:
 this.$ = new Operation(0,0,$$[$0-2],$$[$0],"-"); 
break;
case 111:
 this.$ = new Operation(0,0,$$[$0-2],$$[$0],"*"); 
break;
case 112:
 this.$ = new Operation(0,0,$$[$0-2],$$[$0],"/"); 
break;
case 113:
 this.$ = new Operation(0,0,$$[$0],null,"unary"); 
break;
case 114:
 this.$ = new Operation(0,0,$$[$0-2],$$[$0],"**"); 
break;
case 115:
 this.$ = new Operation(0,0,$$[$0-2],$$[$0],"%"); 
break;
case 116:
 this.$ = new Operation(0,0,$$[$0-2],$$[$0],">"); 
break;
case 117:
 this.$ = new Operation(0,0,$$[$0-2],$$[$0],"<"); 
break;
case 118:
 this.$ = new Operation(0,0,$$[$0-2],$$[$0],">="); 
break;
case 119:
 this.$ = new Operation(0,0,$$[$0-2],$$[$0],"<="); 
break;
case 120:
 this.$ = new Operation(0,0,$$[$0-2],$$[$0],"=="); 
break;
case 121:
 this.$ = new Operation(0,0,$$[$0-2],$$[$0],"!="); 
break;
case 122:
 this.$ = new Operation(0,0,$$[$0-2],$$[$0],"&&"); 
break;
case 123:
 this.$ = new Operation(0,0,$$[$0-2],$$[$0],"||"); 
break;
case 124:
 this.$ = new Operation(0,0,$$[$0],null,"!"); 
break;
case 125:
 this.$ = $$[$0-1]; 
break;
case 126:
 this.$ = new ternaryOp($$[$0-4],$$[$0-2],$$[$0]); 
break;
case 127:
 this.$ = new Operation(0,0,$$[$0-1],null,"INC"); 
break;
case 128:
 this.$ = new Operation(0,0,$$[$0-1],null,"DEC"); 
break;
case 129:
 this.$ = new TObject(0,0,$$[$0],"NUMBER"); 
break;
case 130:
 this.$ = new TObject(0,0,$$[$0].substring(1,$$[$0].length-1),"STRING"); 
break;
case 131:
 this.$ = new TObject(0,0,true,"BOOLEAN"); 
break;
case 132:
 this.$ = new TObject(0,0,false,"BOOLEAN"); 
break;
case 133:
 this.$ = new TObject(0,0,$$[$0],"NULL"); 
break;
case 134:
 this.$ = new TObject(0,0,$$[$0],"UNDEFINED"); 
break;
case 135:
 this.$ = new idVarlast(0,0,$$[$0-1],$$[$0]); 
break;
case 136:
 this.$ = new Id(0,0,$$[$0]); 
break;
case 137:
 this.$ = new callFunction(0,0,$$[$0-4],$$[$0-3],$$[$0-1]); 
break;
case 138:
 this.$ = new ArrList($$[$0-1]); 
break;
case 141:
 this.$ = new ArrParamList($$[$0-2],$$[$0]); 
break;
case 142:
 this.$ = new ArrParamList(null,$$[$0]); 
break;
case 144:
this.$= null;
break;
case 145:
 this.$ = new objList($$[$0-2],$$[$0]); 
break;
case 146:
 this.$ = new objList(null,$$[$0]); 
break;
case 147:

		this.$ = new objProperty($$[$0-2],$$[$0]);
	
break;
}
},
table: [{2:[1,4],3:1,4:2,6:3,9:5,10:6,11:$V0,12:$V1,16:8,17:9,18:10,19:11,20:12,21:13,30:$V2,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},{1:[3]},{5:[1,24],6:25,9:5,10:6,11:$V0,12:$V1,16:8,17:9,18:10,19:11,20:12,21:13,30:$V2,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},o($Va,[2,3]),{7:[1,26],8:[1,27]},o($Va,[2,6]),o($Va,[2,7]),{12:[1,28]},o($Va,[2,9]),o($Va,[2,10]),o($Va,[2,11]),o($Va,[2,12]),o($Va,[2,13]),o($Va,[2,14]),{13:$Vb,22:29,23:$Vc,26:31,59:30,67:32,68:$Vd,71:$Ve,72:$Vf,73:$Vg,74:$Vh,75:$Vi,76:$Vj,77:$Vk},{12:[1,42]},{12:[1,43]},{23:[1,44]},{23:[1,45]},{14:[1,46]},{23:[1,47]},{23:[1,48]},{12:[2,93]},{12:[2,94]},{1:[2,1]},o($Va,[2,2]),o($Va,[2,4]),o($Va,[2,5]),{13:[1,49]},{23:[1,50]},o($Vl,[2,72],{7:[1,51]}),{13:$Vb,23:$Vm,67:52,72:$Vf,73:$Vg,74:$Vh,75:$Vi,76:$Vj,77:$Vk},o($Vn,[2,74]),{12:$Vo,23:$Vp,43:53,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:[1,65]},{12:$Vo,14:$Vz,23:$Vp,29:66,43:67,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:$Vo,14:$Vz,23:$Vp,29:69,43:67,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:$Vo,14:$Vz,23:$Vp,29:70,43:67,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:$Vo,14:$Vz,23:$Vp,29:71,43:67,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:$Vo,14:$Vz,23:$Vp,29:72,43:67,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},o($Vn,[2,84]),o($Vn,[2,85]),o($VA,$VB,{65:73,13:$VC,33:$VD}),{23:[1,76]},{12:$Vo,23:$Vp,43:77,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:$Vo,23:$Vp,43:78,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,35:79,37:80,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},{12:$Vo,23:$Vp,43:91,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:$Vo,23:$Vp,43:93,58:[1,92],68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{14:[1,94]},{12:$Vo,14:$Vz,23:$Vp,24:95,25:$VH,27:96,29:97,43:67,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},o($Vl,[2,71]),o($Vn,[2,73]),{69:[1,98],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{12:$Vo,23:$Vp,43:116,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:$Vo,23:$Vp,43:117,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:$Vo,23:$Vp,43:118,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},o($VZ,[2,129]),o($VZ,[2,130]),o($VZ,[2,131]),o($VZ,[2,132]),o($VZ,[2,133]),o($VZ,[2,134]),o($VZ,[2,136],{26:119,22:120,23:$Vc,68:$Vd,71:$Ve}),{12:$Vo,14:$Vz,23:$Vp,29:123,43:67,68:$Vq,69:[2,140],90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy,111:121,112:122},o($V_,$V$,{70:124,26:125,68:$Vd,71:$Ve}),o($Vn,[2,79]),o($V01,[2,107],{76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY}),{8:[2,144],12:$V11,88:126,113:127,114:128},o($Vn,[2,80]),o($Vn,[2,81]),o($Vn,[2,82]),o($Vn,[2,83]),{7:[2,67],28:[1,131],63:130},{12:$V21,34:132,82:$V31,84:$V41,85:$V51,86:$V61},{12:$Vo,14:$Vz,23:$Vp,29:138,43:67,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:[1,141],25:[2,26],31:139,36:140},{25:[1,142],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{25:[1,143],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{8:[1,144],9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,37:145,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},o($V71,[2,30]),o($V71,[2,31]),o($V71,[2,32]),o($V71,[2,33]),o($V71,[2,34]),o($V71,[2,35]),o($V71,[2,36]),o($V71,[2,37]),{7:[1,146]},{7:[1,147]},{7:[1,150],12:$Vo,14:$Vz,23:$Vp,29:149,41:148,43:67,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{25:[1,151],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{12:[1,152]},{7:[1,154],13:[1,153],60:155,61:$V81,62:$V91,76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{8:[2,87],12:$Va1,15:158,78:159,80:160},{25:[1,162]},{25:[2,18],28:[1,163]},o($Vb1,[2,21]),o($V_,$V$,{26:125,70:164,68:$Vd,71:$Ve}),{12:$Vo,23:$Vp,43:165,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:$Vo,23:$Vp,43:166,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:$Vo,23:$Vp,43:167,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:$Vo,23:$Vp,43:168,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:$Vo,23:$Vp,43:169,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:$Vo,23:$Vp,43:170,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:$Vo,23:$Vp,43:171,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:$Vo,23:$Vp,43:172,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:$Vo,23:$Vp,43:173,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:$Vo,23:$Vp,43:174,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:$Vo,23:$Vp,43:175,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:$Vo,23:$Vp,43:176,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:$Vo,23:$Vp,43:177,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:$Vo,23:$Vp,43:178,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:$Vo,23:$Vp,43:179,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},o($VZ,[2,127]),o($VZ,[2,128]),o($VZ,[2,113]),o($VZ,[2,124]),{25:[1,180],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},o($VZ,[2,135],{23:$Vm}),{23:[1,181]},{69:[1,182]},{28:[1,183],69:[2,139]},o($Vc1,[2,142]),o($V_,[2,76]),o($V_,[2,77]),{8:[1,184]},{7:$Vd1,8:[2,143],28:$Ve1,79:185},o($Vf1,[2,146]),{33:[1,188]},{7:[1,189]},{12:[1,191],64:190},{13:[1,192]},o($Vg1,$Vh1,{83:193,87:194,68:$Vi1}),o($Vg1,$Vh1,{87:194,83:196,68:$Vi1}),o($Vg1,$Vh1,{87:194,83:197,68:$Vi1}),o($Vg1,$Vh1,{87:194,83:198,68:$Vi1}),o($Vg1,$Vh1,{87:194,83:199,68:$Vi1}),o($VA,[2,96]),{25:[1,200]},{25:[2,25],28:[1,201]},{33:[1,202]},{14:[1,203]},{14:[1,204]},{47:[1,205]},o($V71,[2,29]),o($V71,[2,38]),o($V71,[2,39]),o($V71,[2,40]),{7:[1,206]},o($V71,[2,42]),{14:[1,207]},{13:[1,208],60:209,61:$V81,62:$V91},{12:$Vo,23:$Vp,43:210,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:$Vo,23:$Vp,43:211,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:$Vo,23:$Vp,43:212,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},o($Vj1,[2,64]),o($Vj1,[2,65]),{8:[1,213]},{7:$Vd1,8:[2,86],28:$Ve1,79:214},o($Vf1,[2,89]),{33:[1,215]},{7:[1,216]},{12:$Vo,14:$Vz,23:$Vp,29:217,43:67,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},o($V_,[2,75]),o($Vk1,[2,109],{76:$VI,77:$VJ,91:$VM,92:$VN,93:$VO,94:$VP}),o($Vk1,[2,110],{76:$VI,77:$VJ,91:$VM,92:$VN,93:$VO,94:$VP}),o($Vl1,[2,111],{76:$VI,77:$VJ,93:$VO}),o($Vl1,[2,112],{76:$VI,77:$VJ,93:$VO}),o($VZ,[2,114]),o($Vl1,[2,115],{76:$VI,77:$VJ,93:$VO}),o($Vm1,[2,116],{76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP}),o($Vm1,[2,117],{76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP}),o($Vm1,[2,118],{76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP}),o($Vm1,[2,119],{76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP}),o($Vm1,[2,120],{76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP}),o($Vm1,[2,121],{76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP}),o([5,7,8,11,12,13,25,28,30,33,38,39,40,42,47,48,49,53,56,57,58,61,62,69,81,101,102,104],[2,122],{76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV}),o([5,7,8,11,12,13,25,28,30,33,38,39,40,42,47,48,49,53,56,57,58,61,62,69,81,102,104],[2,123],{76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW}),{33:[1,218],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},o($VZ,[2,125]),{12:$Vo,14:$Vz,23:$Vp,24:219,25:$VH,27:96,29:97,43:67,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},o($VZ,[2,138]),{12:$Vo,14:$Vz,23:$Vp,29:220,43:67,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},o($V01,[2,108]),{12:$V11,114:221},{12:[2,90]},{12:[2,91]},{12:$Vo,14:$Vz,23:$Vp,29:222,43:67,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},o($Vl,[2,70]),{7:[2,66],28:[1,223]},o($VA,$VB,{65:224,13:$VC,33:$VD}),{12:$Vo,14:$Vz,23:$Vp,29:225,43:67,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},o($Vg1,[2,98]),o($Vg1,[2,103],{68:[1,226]}),{69:[1,227]},o($Vg1,[2,99]),o($Vg1,[2,100]),o($Vg1,[2,101]),o($Vg1,[2,102]),{14:[1,230],32:228,33:[1,229]},{12:[1,231]},{12:$V21,34:232,82:$V31,84:$V41,85:$V51,86:$V61},{9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,35:233,37:80,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},{9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,35:234,37:80,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},{23:[1,235]},o($V71,[2,41]),{50:236,52:237,53:$Vn1,56:[2,52]},{12:$Vo,23:$Vp,43:239,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:$Vo,23:$Vp,43:240,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{7:[1,241],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{7:[1,242],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{25:[1,243],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{7:[1,244]},{12:$Va1,80:245},{12:$V21,34:246,82:$V31,84:$V41,85:$V51,86:$V61},o($Vl,[2,15]),o($Vb1,[2,20]),{12:$Vo,23:$Vp,43:247,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{25:[1,248]},o($Vc1,[2,141]),o($Vf1,[2,145]),o($Vf1,[2,147]),{12:[1,249]},o($VA,[2,69]),o($VA,[2,95]),{69:[1,250]},o($Vo1,[2,106]),o($Va,[2,22]),{12:$V21,34:251,82:$V31,84:$V41,85:$V51,86:$V61},{9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,35:252,37:80,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},{33:[1,253]},o($Vb1,[2,28]),{8:[1,254],9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,37:145,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},{8:[1,255],9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,37:145,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},{12:$Vo,23:$Vp,43:256,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{51:257,54:258,56:[1,259]},{53:$Vp1,56:[2,51]},{12:$Vo,23:$Vp,43:261,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{7:[1,262],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{25:[1,263],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{12:$Vo,23:$Vp,43:264,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{12:[1,265]},{14:[1,266]},o($Va,[2,8]),o($Vf1,[2,88]),o($Vf1,[2,92]),o([5,7,8,11,12,13,25,28,30,33,38,39,40,42,47,48,49,53,56,57,58,61,62,69,81],[2,126],{76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY}),o($VZ,[2,137]),o($VA,$VB,{65:267,13:$VC,33:$VD}),o($Vo1,[2,105]),{14:[1,268]},{8:[1,269],9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,37:145,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},{12:$V21,34:270,82:$V31,84:$V41,85:$V51,86:$V61},o($Vl,$Vq1,{44:271,45:$Vr1}),o($Vl,[2,48]),{25:[1,273],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{8:[1,274]},{8:[2,58],52:276,53:$Vn1,55:275},{33:[1,277]},{12:$Vo,23:$Vp,43:278,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{33:[1,279],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{12:$Vo,23:$Vp,43:280,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{14:[1,281]},{7:[1,282],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{13:$Vb,26:284,59:283,67:32,68:$Vd,71:$Ve,72:$Vf,73:$Vg,74:$Vh,75:$Vi,76:$Vj,77:$Vk},{9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,35:285,37:80,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},o($VA,[2,68]),{9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,35:286,37:80,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},o($Va,[2,24]),o($Vb1,[2,27]),o($Vl,[2,43]),{14:[1,289],42:[1,288],46:287},{7:[1,290]},o($Vl,[2,50]),{8:[2,55]},{8:[2,57],53:$Vp1},{9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,35:291,37:80,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},{33:[1,292],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,35:293,37:80,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},{7:[1,294],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},{9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,35:295,37:80,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},{12:[1,296]},{25:[1,297]},{13:$Vb,67:52,72:$Vf,73:$Vg,74:$Vh,75:$Vi,76:$Vj,77:$Vk},{8:[1,298],9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,37:145,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},{8:[1,299],9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,37:145,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},o($Vl,[2,44]),{23:[1,300]},{9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,35:301,37:80,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},o($Vl,[2,49]),o([8,53],[2,56],{66:15,9:81,10:82,17:83,18:84,19:85,20:86,21:87,37:145,12:$V1,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,81:$V9}),{9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,35:302,37:80,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},o($Vs1,[2,54],{66:15,9:81,10:82,17:83,18:84,19:85,20:86,21:87,37:145,12:$V1,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,81:$V9}),{12:[1,303]},{8:[1,304],9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,37:145,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},{13:$Vb,26:284,59:305,67:32,68:$Vd,71:$Ve,72:$Vf,73:$Vg,74:$Vh,75:$Vi,76:$Vj,77:$Vk},{14:[1,306]},o($Vl,[2,63]),o($Va,[2,23]),{12:$Vo,23:$Vp,43:307,68:$Vq,90:$Vr,103:$Vs,105:$Vt,106:$Vu,107:$Vv,108:$Vw,109:$Vx,110:$Vy},{8:[1,308],9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,37:145,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},o($Vs1,[2,53],{66:15,9:81,10:82,17:83,18:84,19:85,20:86,21:87,37:145,12:$V1,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,81:$V9}),{13:$Vb,26:284,59:309,67:32,68:$Vd,71:$Ve,72:$Vf,73:$Vg,74:$Vh,75:$Vi,76:$Vj,77:$Vk},o($Vl,[2,62]),{25:[1,310]},{9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,35:311,37:80,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},{25:[1,312],76:$VI,77:$VJ,89:$VK,90:$VL,91:$VM,92:$VN,93:$VO,94:$VP,95:$VQ,96:$VR,97:$VS,98:$VT,99:$VU,100:$VV,101:$VW,102:$VX,104:$VY},o($Vl,[2,47]),{25:[1,313]},{14:[1,314]},{8:[1,315],9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,37:145,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},{14:[1,316]},{14:[1,317]},{9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,35:318,37:80,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},o($Vl,[2,61]),{9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,35:319,37:80,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},{9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,35:320,37:80,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},{8:[1,321],9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,37:145,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},{8:[1,322],9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,37:145,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},{8:[1,323],9:81,10:82,12:$V1,17:83,18:84,19:85,20:86,21:87,37:145,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:15,81:$V9},o($Vl,[2,60]),o($Vl,$Vq1,{44:324,45:$Vr1}),o($Vl,[2,59]),o($Vl,[2,46])],
defaultActions: {22:[2,93],23:[2,94],24:[2,1],186:[2,90],187:[2,91],275:[2,55]},
parseError: function parseError (str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
    }
},
parse: function parse (input) {
    var self = this,
        stack = [0],
        tstack = [], // token stack
        vstack = [null], // semantic value stack
        lstack = [], // location stack
        table = this.table,
        yytext = '',
        yylineno = 0,
        yyleng = 0,
        recovering = 0,
        TERROR = 2,
        EOF = 1;

    var args = lstack.slice.call(arguments, 1);

    //this.reductionCount = this.shiftCount = 0;

    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    // copy state
    for (var k in this.yy) {
      if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
        sharedState.yy[k] = this.yy[k];
      }
    }

    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);

    var ranges = lexer.options && lexer.options.ranges;

    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }

    function popStack (n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }

_token_stack:
    var lex = function () {
        var token;
        token = lexer.lex() || EOF;
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }
        return token;
    }

    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        // retreive state number from top of stack
        state = stack[stack.length - 1];

        // use default actions if available
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            // read action for current state and first input
            action = table[state] && table[state][symbol];
        }

_handle_error:
        // handle parse error
        if (typeof action === 'undefined' || !action.length || !action[0]) {
            var error_rule_depth;
            var errStr = '';

            // Return the rule stack depth where the nearest error rule can be found.
            // Return FALSE when no error recovery rule was found.
            function locateNearestErrorRecoveryRule(state) {
                var stack_probe = stack.length - 1;
                var depth = 0;

                // try to recover from error
                for(;;) {
                    // check for error recovery rule in this state
                    if ((TERROR.toString()) in table[state]) {
                        return depth;
                    }
                    if (state === 0 || stack_probe < 2) {
                        return false; // No suitable error recovery rule available.
                    }
                    stack_probe -= 2; // popStack(1): [symbol, action]
                    state = stack[stack_probe];
                    ++depth;
                }
            }

            if (!recovering) {
                // first see if there's any chance at hitting an error recovery rule:
                error_rule_depth = locateNearestErrorRecoveryRule(state);

                // Report error
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push("'"+this.terminals_[p]+"'");
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line '+(yylineno+1)+":\n"+lexer.showPosition()+"\nExpecting "+expected.join(', ') + ", got '" + (this.terminals_[symbol] || symbol)+ "'";
                } else {
                    errStr = 'Parse error on line '+(yylineno+1)+": Unexpected " +
                                  (symbol == EOF ? "end of input" :
                                              ("'"+(this.terminals_[symbol] || symbol)+"'"));
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected,
                    recoverable: (error_rule_depth !== false)
                });
            } else if (preErrorSymbol !== EOF) {
                error_rule_depth = locateNearestErrorRecoveryRule(state);
            }

            // just recovered from another error
            if (recovering == 3) {
                if (symbol === EOF || preErrorSymbol === EOF) {
                    throw new Error(errStr || 'Parsing halted while starting to recover from another error.');
                }

                // discard current lookahead and grab another
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                symbol = lex();
            }

            // try to recover from error
            if (error_rule_depth === false) {
                throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');
            }
            popStack(error_rule_depth);

            preErrorSymbol = (symbol == TERROR ? null : symbol); // save the lookahead token
            symbol = TERROR;         // insert generic error symbol as new lookahead
            state = stack[stack.length-1];
            action = table[state] && table[state][TERROR];
            recovering = 3; // allow 3 real symbols to be shifted before reporting a new error
        }

        // this shouldn't happen, unless resolve defaults are off
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: '+state+', token: '+symbol);
        }

        switch (action[0]) {
            case 1: // shift
                //this.shiftCount++;

                stack.push(symbol);
                vstack.push(lexer.yytext);
                lstack.push(lexer.yylloc);
                stack.push(action[1]); // push state
                symbol = null;
                if (!preErrorSymbol) { // normal execution/no error
                    yyleng = lexer.yyleng;
                    yytext = lexer.yytext;
                    yylineno = lexer.yylineno;
                    yyloc = lexer.yylloc;
                    if (recovering > 0) {
                        recovering--;
                    }
                } else {
                    // error just occurred, resume old lookahead f/ before error
                    symbol = preErrorSymbol;
                    preErrorSymbol = null;
                }
                break;

            case 2:
                // reduce
                //this.reductionCount++;

                len = this.productions_[action[1]][1];

                // perform semantic action
                yyval.$ = vstack[vstack.length-len]; // default to $$ = $1
                // default location, uses first token for firsts, last for lasts
                yyval._$ = {
                    first_line: lstack[lstack.length-(len||1)].first_line,
                    last_line: lstack[lstack.length-1].last_line,
                    first_column: lstack[lstack.length-(len||1)].first_column,
                    last_column: lstack[lstack.length-1].last_column
                };
                if (ranges) {
                  yyval._$.range = [lstack[lstack.length-(len||1)].range[0], lstack[lstack.length-1].range[1]];
                }
                r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));

                if (typeof r !== 'undefined') {
                    return r;
                }

                // pop off stack
                if (len) {
                    stack = stack.slice(0,-1*len*2);
                    vstack = vstack.slice(0, -1*len);
                    lstack = lstack.slice(0, -1*len);
                }

                stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)
                vstack.push(yyval.$);
                lstack.push(yyval._$);
                // goto new state = table[STATE][NONTERMINAL]
                newState = table[stack[stack.length-2]][stack[stack.length-1]];
                stack.push(newState);
                break;

            case 3:
                // accept
                return true;
        }

    }

    return true;
}};

	
	let tablaErrores = [];	
	if(tablaErrores.length != 0) {
		tablaErrores = [];
	}

	const defLast = require('./ejecucion/defLast.js');
	const callFunction = require('./ejecucion/callFunction.js');
    const TObject = require('./ejecucion/TObject.js');
	const Operation = require('./ejecucion/Operation.js');
	const idList = require('./ejecucion/idList.js');
	const Variable = require('./ejecucion/Variable.js');
	const Type = require('./ejecucion/Type.js');
	const decType = require('./ejecucion/decType.js');
	const objType = require('./ejecucion/objType.js');
	const typeKeyValue  = require('./ejecucion/typeKeyValue.js');
	const Id  = require('./ejecucion/Id.js');
	const typeList  = require('./ejecucion/typeList.js');
	const ArrList = require('./ejecucion/ArrList.js');
	const ArrParamList = require('./ejecucion/ArrParamList.js')
	const objList = require('./ejecucion/objList.js')
	const Obj = require('./ejecucion/Obj.js')
	const objProperty = require('./ejecucion/objProperty.js')
	const idVarlast = require('./ejecucion/idVarlast.js')
	const defVarLast = require('./ejecucion/defVarLast.js')
	const defVarLastP = require('./ejecucion/defVarLastP.js')
	const asignLastF = require('./ejecucion/asignLastF.js')
	const asignLast = require('./ejecucion/asignLast.js')
	const asignVariable = require('./ejecucion/asignVariable.js')
	const ternaryOp = require('./ejecucion/ternaryOp.js')
	const While = require('./ejecucion/While.js')
	const EscapeExp = require('./ejecucion/EscapeExp.js')
	const doWhile = require('./ejecucion/doWhile.js')
	const IF = require('./ejecucion/IF.js')

	const Defcase = require('./ejecucion/Defcase.js')
	const Case = require('./ejecucion/Case.js')
	const Switch = require('./ejecucion/Switch.js')

	const ForNormal = require('./ejecucion/ForNormal.js')
	const ForTwo = require('./ejecucion/ForTwo.js')
	const ForThree = require('./ejecucion/ForThree.js')
	const ForEach = require('./ejecucion/ForEach.js')

	const Function = require('./ejecucion/Function.js')
	const FuncDec = require('./ejecucion/FuncDec.js')
/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function(match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex () {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin (condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState () {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules () {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState (n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState (condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {"case-sensitive":true},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0://Comentario Linea
break;
case 1://Comentaio Multilinea
break;
case 2:return 39;
break;
case 3:return 38;
break;
case 4:return 109;
break;
case 5:return 11;
break;
case 6:return 81;
break;
case 7:return 58;
break;
case 8:return 81;
break;
case 9:return 30;
break;
case 10:return 42;
break;
case 11:return 45;
break;
case 12:return 47;
break;
case 13:return 48;
break;
case 14:return 49;
break;
case 15:return 53;
break;
case 16:return 56;
break;
case 17:return 57;
break;
case 18:return 61;
break;
case 19:return 62;
break;
case 20:return 82;
break;
case 21:return 84;
break;
case 22:return 85;
break;
case 23:return 86;
break;
case 24:return 107;
break;
case 25:return 108;
break;
case 26:return 110;
break;
case 27:return 40;
break;
case 28:return 72;
break;
case 29:return 73;
break;
case 30:return 74;
break;
case 31:return 75;
break;
case 32:return 14;
break;
case 33:return 8;
break;
case 34:return 23;
break;
case 35:return 25;
break;
case 36:return 28;
break;
case 37:return 7;
break;
case 38:return 33;
break;
case 39:return 71;
break;
case 40:return 76;
break;
case 41:return 77;
break;
case 42:return 89;
break;
case 43:return 90;
break;
case 44:return 93;
break;
case 45:return 91;
break;
case 46:return 92;
break;
case 47:return 94;
break;
case 48:return 97;
break;
case 49:return 98;
break;
case 50:return 95;
break;
case 51:return 96;
break;
case 52:return 99;
break;
case 53:return 13;
break;
case 54:return 100;
break;
case 55:return 101;
break;
case 56:return 102;
break;
case 57:return 103;
break;
case 58:return 104;
break;
case 59:return 68;
break;
case 60:return 69;
break;
case 61:
break;
case 62:
break;
case 63:
break;
case 64:
break;
case 65:return 105;
break;
case 66:return 106;
break;
case 67:return 12;
break;
case 68:return 5;
break;
case 69: 
	console.error('Este es un error léxico: ' + yy_.yytext + ', en la linea: ' + yy_.yylloc.first_line + ', en la columna: ' + yy_.yylloc.first_column); 
	tablaErrores.push({line:yy_.yylloc.first_line, column:yy_.yylloc.first_column, type:'Lexico',msg:'El caracter: ' + yy_.yytext + " no se esperaba"})

	
break;
}
},
rules: [/^(?:\/\/.*)/,/^(?:[\/][*][^*]*[*]+([^\/*][^*]*[*]+)*[\/])/,/^(?:continue\b)/,/^(?:break\b)/,/^(?:null\b)/,/^(?:type\b)/,/^(?:const\b)/,/^(?:let\b)/,/^(?:const\b)/,/^(?:function\b)/,/^(?:if\b)/,/^(?:else\b)/,/^(?:while\b)/,/^(?:do\b)/,/^(?:switch\b)/,/^(?:case\b)/,/^(?:default\b)/,/^(?:for\b)/,/^(?:in\b)/,/^(?:of\b)/,/^(?:number\b)/,/^(?:boolean\b)/,/^(?:string\b)/,/^(?:void\b)/,/^(?:true\b)/,/^(?:false\b)/,/^(?:undefined\b)/,/^(?:return\b)/,/^(?:\+=)/,/^(?:-=)/,/^(?:\*=)/,/^(?:\/=)/,/^(?:\{)/,/^(?:\})/,/^(?:\()/,/^(?:\))/,/^(?:,)/,/^(?:;)/,/^(?::)/,/^(?:\.)/,/^(?:\+\+)/,/^(?:--)/,/^(?:\+)/,/^(?:-)/,/^(?:\*\*)/,/^(?:\*)/,/^(?:\/)/,/^(?:%)/,/^(?:>=)/,/^(?:<=)/,/^(?:>)/,/^(?:<)/,/^(?:==)/,/^(?:=)/,/^(?:!=)/,/^(?:&&)/,/^(?:\|\|)/,/^(?:!)/,/^(?:\?)/,/^(?:\[)/,/^(?:\])/,/^(?:\s+)/,/^(?:\t+)/,/^(?:\r+)/,/^(?:\n+)/,/^(?:[0-9]+(\.[0-9]+)?\b)/,/^(?:"[^\"]*"|'[^\']*'|`[^\`]*`)/,/^(?:([a-zA-Z$_])[a-zA-Z0-9_$]*)/,/^(?:$)/,/^(?:.)/],
conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = ejecucion;
exports.Parser = ejecucion.Parser;
exports.parse = function () { return ejecucion.parse.apply(ejecucion, arguments); };
exports.main = function commonjsMain (args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
}
}).call(this,require('_process'))
},{"./ejecucion/ArrList.js":5,"./ejecucion/ArrParamList.js":6,"./ejecucion/Case.js":7,"./ejecucion/Defcase.js":8,"./ejecucion/EscapeExp.js":9,"./ejecucion/ForEach.js":10,"./ejecucion/ForNormal.js":11,"./ejecucion/ForThree.js":12,"./ejecucion/ForTwo.js":13,"./ejecucion/FuncDec.js":14,"./ejecucion/Function.js":15,"./ejecucion/IF.js":16,"./ejecucion/Id.js":17,"./ejecucion/Obj.js":19,"./ejecucion/Operation.js":20,"./ejecucion/Switch.js":22,"./ejecucion/TObject.js":23,"./ejecucion/Type.js":24,"./ejecucion/Variable.js":25,"./ejecucion/While.js":26,"./ejecucion/asignLast.js":27,"./ejecucion/asignLastF.js":28,"./ejecucion/asignVariable.js":29,"./ejecucion/callFunction.js":30,"./ejecucion/decType.js":31,"./ejecucion/defLast.js":32,"./ejecucion/defVarLast.js":33,"./ejecucion/defVarLastP.js":34,"./ejecucion/doWhile.js":35,"./ejecucion/idList.js":36,"./ejecucion/idVarlast.js":37,"./ejecucion/objList.js":38,"./ejecucion/objProperty.js":39,"./ejecucion/objType.js":40,"./ejecucion/ternaryOp.js":41,"./ejecucion/typeKeyValue.js":42,"./ejecucion/typeList.js":43,"_process":112,"fs":107,"path":111}],5:[function(require,module,exports){
class ArrList {

    constructor(arr) {
        this.arr = arr;
    }

    run(scope,console) {
        if(this.arr != null) {
            var a = this.arr.run(scope,console);
            return {value:a.arr,type:a.type,isArray:true,dim:1}
        }

        return {value:[],type:"NULL",isArray:true,dim:0}
    }
    
}

module.exports = ArrList;
},{}],6:[function(require,module,exports){
class ArrParamList {

    constructor(list,exp) {
        this.list = list;
        this.exp = exp;
    }

    run(scope, console) {
        if(this.list != null) {
            var e = this.exp.run(scope, console);
            var l = this.list.run(scope, console);
            l.arr.push(e);
            return l;
        } else {
            var e = this.exp.run(scope, console);
            return {arr:[e],type:e.type};
        }
    }
}

module.exports = ArrParamList;
},{}],7:[function(require,module,exports){
const Operation = require('./Operation.js');
const Scope = require('./Scope.js')
class Case {

    constructor(list) {
        this.list = list;
    }

    run(scope,cond,console) {
        for(var i = 0;i<this.list.length;i++) {
            var element = this.list[i];
            var exp = element.exp/*.run(scope)*/;
            var stmt = element.stmt;
            
            var op = new Operation(0,0,cond,exp,"==");
            var result = op.run(scope,console);

            if(result.type == 'BOOLEAN' && !result.isArray) {

                //console.log(result);
                result = Boolean(result.value);
                //console.log(result);
                if(result) {
                    var actualScope = new Scope(scope);
                    var aux = this.statement(actualScope,stmt,console);
                    if(aux != null) {
    
                        if(aux.type == 'RETURN') {
                            return aux;
                        } else if(aux.type == 'BREAK') {
                            return aux;
                        } else if(aux.type == 'CONTINUE') {
                            return aux;
                        }
                    }
                }

            } else {
                //error
                console.log("Error 1 en Case.js")
                return;
            }
        }
    }

    statement(scope,stmt,console) {
        if(stmt!= null) {
            for(var i = 0;i<stmt.length;i++) {
                var element = stmt[i];
                var aux = element.run(scope,console);
                if(aux != null) {
    
                    if(aux.type == 'RETURN') {
                        return aux;
                    } else if(aux.type == 'BREAK') {
                        return aux;
                    } else if(aux.type == 'CONTINUE') {
                        return aux;
                    }
                }
            }     
        }
    }
}

module.exports = Case;
},{"./Operation.js":20,"./Scope.js":21}],8:[function(require,module,exports){
const Scope = require('./Scope.js');
class Defcase {

    constructor(stmt) {
        this.stmt = stmt;
    }

    run(scope,console){ 
        var actualScope = new Scope(scope);
        if(this.stmt!= null) {
            for(var i = 0;i<this.stmt.length;i++) {
                var element = this.stmt[i];
                var aux = element.run(actualScope,console);
                if(aux != null) {
    
                    if(aux.type == 'RETURN') {
                        return aux;
                    } else if(aux.type == 'BREAK') {
                        return aux;
                    } else if(aux.type == 'CONTINUE') {
                        return aux;
                    }
                }
            }     
        }
    }
}

module.exports = Defcase;
},{"./Scope.js":21}],9:[function(require,module,exports){
class EscapeExp {

    constructor(type,exp) {
        this.type = type;
        this.exp = exp;
    }

    run(scope,console) {

        if(this.type == 'BREAK') {
            return {type:'BREAK'}
        } else if(this.type == 'CONTINUE') {
            return {type:'CONTINUE'}
        } else if(this.type == "RETURN"){
            //console.log(this.exp)
            if(this.exp != null) {

                var res = this.exp.run(scope,console);
                return {type:"RETURN",res:res}
            }
            return {type:"RETURN"}
        }
    }

}
module.exports = EscapeExp;
},{}],10:[function(require,module,exports){
const TObject = require("./TObject");
const Variable = require("./Variable");
const defLast = require("./defLast");
const Scope = require("./Scope");
const asignLast = require("./asignLast")
const asignLastF = require("./asignLastF")
const asignVariable = require("./asignVariable")
class ForEach{

    constructor(isDec,id,forOp,arr,stmt){
        this.isDec = isDec;
        this.id = id;
        this.forOp = forOp;
        this.arr = arr;
        this.stmt = stmt;
    }
    
    run(scope,console) {

        var obj = this.arr.run(scope,console);
        if(obj.isArray || !this.isPrimitive(obj)) {

            if(this.forOp == 'in') {
                return this.forIn(obj,scope,console);
            } else {
                return this.forOf(obj,scope,console)
            }

        } else {
            //ERROR
            console.log("Error 1 en ForEach.js")
            return;
        }
    }

    forIn(obj,scope,console) {

        if(this.isDec) {

            var id = this.id;
            var asgn = new Variable(0,0,'let',id,new defLast(0,0,null,new TObject(0,0,"null",'NULL')),null);
            
            var actualScope = new Scope(scope);
            
            asgn.run(actualScope,console);
            var array = this.arr.run(scope,console);

            if(array.constructor.name == "Map") {

                for (const key of array.keys()) {
                    
                    var newScope = new Scope(actualScope);

                    var rasign = new asignVariable(id,new asignLast(null,new asignLastF(null,new TObject(0,0,key.toString(),"STRING"))));
                    rasign.run(newScope,console)
                    var aux = this.statement(newScope,console);
                    if(aux != null) {
    
                        if(aux.type == 'RETURN') {
                            return aux;
                        } else if(aux.type == 'BREAK') {
                            break;
                        } 
                    }
                }

            } else {
                array = array.value;
                for (const key in array) {

                    var newScope = new Scope(actualScope);

                    var rasign = new asignVariable(id,new asignLast(null,new asignLastF(null,new TObject(0,0,key.toString(),"NUMBER"))));
                    rasign.run(newScope,console)
                    var aux = this.statement(newScope,console);
                    if(aux != null) {
    
                        if(aux.type == 'RETURN') {
                            return aux;
                        } else if(aux.type == 'BREAK') {
                            break;
                        } 
                    }
                }
            }

        } else {

            if(this.id.constructor.name == "Id") {

                var id = this.id.id;
                if(scope.findVariable(id)){

                    var actualScope = new Scope(scope);

                    var array = this.arr.run(scope,console);
                    if(array.constructor.name == "Map") {

                        for (const key of array.keys()) {
                            
                            var newScope = new Scope(actualScope);

                            var rasign = new asignVariable(id,new asignLast(null,new asignLastF(null,new TObject(0,0,key.toString(),"STRING"))));
                            rasign.run(newScope,console)
                            var aux = this.statement(newScope,console);
                            if(aux != null) {
            
                                if(aux.type == 'RETURN') {
                                    return aux;
                                } else if(aux.type == 'BREAK') {
                                    break;
                                } 
                            }
                        }

                    } else {
                        array = array.value;
                        
                        for (const key in array) {
                            
                            var newScope = new Scope(actualScope);
                            
                            var rasign = new asignVariable(id,new asignLast(null,new asignLastF(null,new TObject(0,0,key.toString(),"NUMBER"))));
                            rasign.run(newScope,console)
                            var aux = this.statement(newScope,console);
                            if(aux != null) {
            
                                if(aux.type == 'RETURN') {
                                    return aux;
                                } else if(aux.type == 'BREAK') {
                                    break;
                                } 
                            }
                        }
                    }


                } else {
                    //ERROR
                    console.log("Error 2 en ForEach.js")
                }

            } else {
                //Error
                console.log("Error 3 en ForEach.js")
                console.log("ERROR se esperaba un id")
            }

        }

        return null;
    }

    forOf(obj,scope,console) {

        if(this.isDec) {

            var id = this.id;
            var asgn = new Variable(0,0,'let',id,new defLast(0,0,null,new TObject(0,0,"null",'NULL')),null);
            var actualScope = new Scope(scope);
            asgn.run(actualScope,console);
            var array = this.arr.run(scope,console);
            if(array.constructor.name == "Map") {

                console.log("Error 4 en ForEach.js")
                return null;

            } else {
                array = array.value;
                for (let value of array) {

                    var newScope = new Scope(actualScope);

                    var rasign = new asignVariable(id,new asignLast(null,new asignLastF(null,value)));
                    rasign.run(newScope,console)
                    var aux = this.statement(newScope,console);
                    if(aux != null) {
    
                        if(aux.type == 'RETURN') {
                            return aux;
                        } else if(aux.type == 'BREAK') {
                            break;
                        } 
                    }
                }
            }

        } else {
            if(this.id.constructor.name == "Id") {

                var id = this.id.id;
                if(scope.findVariable(id)){

                    var actualScope = new Scope(scope);

                    var array = this.arr.run(scope,console);
                    if(array.constructor.name == "Map") {
                        //ERROR
                        console.log("Error 5 en ForEach.js")
                        return null;
                    } else {
                        array = array.value;
                        
                        for (const key of array) {

                            var newScope = new Scope(actualScope);

                            var rasign = new asignVariable(id,new asignLast(null,new asignLastF(null,key)));
                            rasign.run(newScope,console)
                            var aux = this.statement(newScope,console);
                            if(aux != null) {
            
                                if(aux.type == 'RETURN') {
                                    return aux;
                                } else if(aux.type == 'BREAK') {
                                    break;
                                } 
                            }
                        }
                    }


                } else {
                    //ERROR
                    console.log("Error 6 en ForEach.js")
                }

            } else {
                //Error
                console.log("Error 7 en ForEach.js")
                console.log("ERROR se esperaba un id")
            }
        }

        return null;
    }
    
    statement(scope,console) {
        if(this.stmt!= null) {
            for(var i = 0;i<this.stmt.length;i++) {
                var element = this.stmt[i];
                var aux = element.run(scope,console);
                if(aux != null) {
    
                    if(aux.type == 'RETURN') {
                        return aux;
                    } else if(aux.type == 'BREAK') {
                        return aux;
                    } else if(aux.type == 'CONTINUE') {
                        return null;
                    }
                }
            }     
        }
    }

    isPrimitive(obj) {
        switch(obj.type) {
            case 'NUMBER':
                return true;
            case 'BOOLEAN':
                return true;
            case 'STRING':
                return true;
            case 'NULL':
                return true;
            case 'UNDEFINED':
                return true
            default:
                return false;    
        }
    }
}

module.exports = ForEach;
},{"./Scope":21,"./TObject":23,"./Variable":25,"./asignLast":27,"./asignLastF":28,"./asignVariable":29,"./defLast":32}],11:[function(require,module,exports){
const Scope = require('./Scope.js');
class ForNormal {

    constructor(id,expAsign,cond,inc,stmt) {
        this.id = id;
        this.expAsign = expAsign;
        this.cond = cond;
        this.inc = inc;
        this.stmt = stmt;
    }

    run(scope,console) {

        var exp = this.expAsign.run(scope,console);
        var actualScope = new Scope(scope);
        
        var objAsgn = {value:exp,type:exp.type,isArray:exp.isArray,dim:exp.dim,dectype:'let'}
        actualScope.insertVariable(this.id,objAsgn);

        var condition = this.cond.run(actualScope,console);

        if(condition.type == 'BOOLEAN') {
            condition = Boolean(condition.value);
            while(condition) {

                var newScope = new Scope(actualScope);

                var aux = this.statement(newScope,console);
                
                if(aux != null) {
    
                    if(aux.type == 'RETURN') {
                        return aux;
                    } else if(aux.type == 'BREAK') {
                        break;
                    } 
                }
                
                this.inc.run(newScope,console);
                condition = this.cond.run(newScope,console);
                condition = Boolean(condition.value);
                
            }

        } else {
            //Error;
            console.log("Error 1 en ForNormal.js")
        }
        
    }

    statement(scope,console) {
        if(this.stmt!= null) {
            for(var i = 0;i<this.stmt.length;i++) {
                var element = this.stmt[i];
                var aux = element.run(scope,console);
                if(aux != null) {
    
                    if(aux.type == 'RETURN') {
                        return aux;
                    } else if(aux.type == 'BREAK') {
                        return aux;
                    } else if(aux.type == 'CONTINUE') {
                        return null;
                    }
                }
            }     
        }
    }
}
module.exports = ForNormal;
},{"./Scope.js":21}],12:[function(require,module,exports){
const Scope = require('./Scope.js');
const asignLast = require('./asignLast.js')
const asignLastF = require('./asignLastF.js')
const asignVariable = require('./asignVariable.js')

class ForTwo {

    constructor(id,cond,inc,stmt) {
        this.id = id;
        this.cond = cond;
        this.inc = inc;
        this.stmt = stmt;
    }

    run(scope,console) {
        
        if(this.id.constructor.name == "Id") {
            
            var actualScope = new Scope(scope);
            var id = this.id.id;
            if(id != this.inc.id) {
                //ERROR
                console.log("Error 1 en ForThree.js")
                return;
            }
           /* var exp = this.expAsign.run(actualScope);
            var asignLast_ = new asignLast(null,new asignLastF(null,exp));
            var asign = new asignVariable(id,asignLast_);

            asign.run(actualScope);*/
            var condition = this.cond.run(actualScope,console);
            if(condition.type == 'BOOLEAN') {
                
                condition = Boolean(condition.value);
                while(condition) {

                    var newScope = new Scope(actualScope);

                    var aux = this.statement(newScope,console);
                    
                    if(aux != null) {
        
                        if(aux.type == 'RETURN') {
                            return aux;
                        } else if(aux.type == 'BREAK') {
                            break;
                        } 
                    }
                    
                    this.inc.run(newScope,console);
                    condition = this.cond.run(newScope,console);
                    condition = Boolean(condition.value);
                    
                }
            } else {
                console.log("No se que va aqui ForThree")
            }

        } else {
            //ERROR
            console.log("Error 2 en ForThree.js")
        }
    }

    statement(scope,console) {
        if(this.stmt!= null) {
            for(var i = 0;i<this.stmt.length;i++) {
                var element = this.stmt[i];
                var aux = element.run(scope,console);
                if(aux != null) {
    
                    if(aux.type == 'RETURN') {
                        return aux;
                    } else if(aux.type == 'BREAK') {
                        return aux;
                    } else if(aux.type == 'CONTINUE') {
                        return null;
                    }
                }
            }     
        }
    }
}

module.exports = ForTwo;

},{"./Scope.js":21,"./asignLast.js":27,"./asignLastF.js":28,"./asignVariable.js":29}],13:[function(require,module,exports){
const Scope = require('./Scope.js');
const asignLast = require('./asignLast.js')
const asignLastF = require('./asignLastF.js')
const asignVariable = require('./asignVariable.js')

class ForTwo {

    constructor(id,expAsign,cond,inc,stmt) {
        this.id = id;
        this.expAsign = expAsign;
        this.cond = cond;
        this.inc = inc;
        this.stmt = stmt;
    }

    run(scope,console) {
        
        if(this.id.constructor.name == "Id") {
            
            var actualScope = new Scope(scope);
            var id = this.id.id;
            if(id != this.inc.id) {
                //ERROR
                console.log("Error 1 en ForTwo.js")
                return;
            }
            var exp = this.expAsign.run(actualScope,console);
            var asignLast_ = new asignLast(null,new asignLastF(null,exp));
            var asign = new asignVariable(id,asignLast_);

            asign.run(actualScope,console);
            var condition = this.cond.run(actualScope,console);

            if(condition.type == 'BOOLEAN') {
                
                condition = Boolean(condition.value);
                while(condition) {

                    var newScope = new Scope(actualScope);

                    var aux = this.statement(newScope,console);
                    
                    if(aux != null) {
        
                        if(aux.type == 'RETURN') {
                            return aux;
                        } else if(aux.type == 'BREAK') {
                            break;
                        } 
                    }
                    
                    this.inc.run(newScope,console);
                    condition = this.cond.run(newScope,console);
                    condition = Boolean(condition.value);
                    
                }
            } else {
                console.log("no se que va aqui ForTwo");
            }

        } else {
            //ERROR
            console.log("Error 2 en ForTwo.js")
        }
    }

    statement(scope,console) {
        if(this.stmt!= null) {
            for(var i = 0;i<this.stmt.length;i++) {
                var element = this.stmt[i];
                var aux = element.run(scope,console);
                if(aux != null) {
    
                    if(aux.type == 'RETURN') {
                        return aux;
                    } else if(aux.type == 'BREAK') {
                        return aux;
                    } else if(aux.type == 'CONTINUE') {
                        return null;
                    }
                }
            }     
        }
    }
}

module.exports = ForTwo;
},{"./Scope.js":21,"./asignLast.js":27,"./asignLastF.js":28,"./asignVariable.js":29}],14:[function(require,module,exports){

class FuncDec {

    constructor(hasType,type,STMT) {
        this.hasType = hasType;
        this.type = type;
        this.STMT = STMT;
    }

    run(scope,console) {
        
        if(this.hasType) {
            return {stmt:this.STMT,type:this.type.run(scope,console)}
        } else {
            return {stmt:this.STMT,type:undefined};
        }
    }

}

module.exports = FuncDec;
},{}],15:[function(require,module,exports){

class Function {

    constructor(id,param,funcDec) {
        this.id = id;
        this.param = param;
        this.funcDec = funcDec;
    }

    run(scope,console) {
        var obj = this.funcDec.run(scope,console);
        var func;
        if(obj.type)
            func = obj.type;
        else
            func = {type:'VOID',isArray:false,dim:0}
            
        //console.log(obj)
        func.param = this.param;
        func.stmt = obj.stmt;
        var r = scope.insertFunction(this.id,func);
        if(!r) {
            console.log("Error 1 en Function.js")
        }
    }
}

module.exports = Function;
},{}],16:[function(require,module,exports){
const Scope = require('./Scope.js') 
class IF {

    constructor(cond,stmt,iflast) {
        this.cond   = cond;
        this.stmt   = stmt;
        this.iflast = iflast;
    }

    run(scope,console) {
        
        if(this.cond != null) {
            /*console.log("IF----")
            console.log(this.cond)
            console.log("----.-----")*/
            var auxCond = this.cond.run(scope,console);
            /*console.log("cual es el resultado de la condicion")
            console.log(auxCond)
            console.log("°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°")*/
            if(auxCond.type == 'BOOLEAN') {

                auxCond = Boolean(auxCond.value);
                var actualScope = new Scope(scope);

                if(auxCond) {

                    var r = this.statement(actualScope,console)
                    if(r != null && r != undefined) {
                        if(r.type == 'RETURN') {
                            return r;
                        } else if(r.type == 'BREAK') {
                            return r;
                        } else if(r.type == 'CONTINUE') {
                            return r;
                        } 
                    }

                } else {

                    if(this.iflast != null) {
                        var actualScope = new Scope(scope);
                        var ifr = this.iflast.run(actualScope,console);
                        if(ifr != null && ifr != undefined) {
                            if(ifr.type == 'RETURN') {
                                return ifr;
                            } else if(ifr.type == 'BREAK') {
                                return ifr;
                            } else if(ifr.type == 'CONTINUE') {
                                return ifr;
                            } 
                        }
                    }
                }

            } else {
                //ERROR
                console.log("ERROR 1 en IF.js")
            }

        } else {

            var actualScope = new Scope(scope);
            var r = this.statement(actualScope,console);
            if(r != null && r != undefined) {
                if(r.type == 'RETURN') {
                    return r;
                } else if(r.type == 'BREAK') {
                    return r;
                } else if(r.type == 'CONTINUE') {
                    return r;
                } 
            }

        }
    }

    statement(scope,console) {
        if(this.stmt!= null) {
            for(var i = 0;i<this.stmt.length;i++) {
                var element = this.stmt[i];
                var aux = element.run(scope,console);
                if(aux != null) {
    
                    if(aux.type == 'RETURN') {
                        return aux;
                    } else if(aux.type == 'BREAK') {
                        return aux;
                    } else if(aux.type == 'CONTINUE') {
                        return aux;
                    }
                }
            }     
        }
    }

}
module.exports = IF;
},{"./Scope.js":21}],17:[function(require,module,exports){
const TObject = require('./TObject')
class Id {

    constructor(line,column,id) {
        this.line = line;
        this.column = column;
        this.id = id;
    }

    run(scope,consoleT) {
        
        var r = scope.findVariable(this.id);
        /*console.log("!!!!!!!!!!OBJ!!!!!!!!!!!1")
        console.log(r)
        console.log("!!!!!!!!!!!!!!!!!!!!!1")*/
        if(r != null) {
            if(r.value == undefined || r.value == null) {
                return r;
            }
            return r.value;
        } else {
            //ERROR
            console.log("ERROR en Id.js")
            
        }
        return new TObject(0,0,"undefined","UNDEFINED")
    }
}

module.exports = Id;
},{"./TObject":23}],18:[function(require,module,exports){
class Nodo {
    constructor(line,column,value) {
        this.line = line;
        this.column = column;
        this.value = value;
    }

}
module.exports = Nodo;
},{}],19:[function(require,module,exports){
class Obj {
    
    constructor(obj) {
        this.obj = obj;
    }

    run(scope,console) {
        var ob = this.obj.run(scope,console);
        //console.log(ob)
        return { value:ob,type:"OBJ",isArray:false,dim:0 };
    }
}
module.exports = Obj;
},{}],20:[function(require,module,exports){
const Nodo = require('./Nodo.js');
const TObject = require('./TObject.js');
class Operation extends Nodo{

    constructor(line,column,opIzq,opDer,operator) {
        super(line,column,null);
        this.opIzq = opIzq;
        this.opDer = opDer;
        this.operator = operator;
    }

    

    run(scope,console) {
        let valIzq;
        let valDer;
        /*console.log("$$$$$$$$$$||AL inicio del run en operation|||$$$$$$$$$$$")
        console.log(this.opIzq)
        console.log(this.opDer)
        console.log("|||||||||||||||||||||||||||||||||||||||||||||||||||||")*/
        if(this.opIzq != null)
            valIzq = this.opIzq.run(scope,console);
        if(this.opDer != null)
            valDer = this.opDer.run(scope,console);
        
        /*console.log("$$$$$$$$$$--Aqui se ejecuta en operacion-$$$$$$$$$$$")
        console.log(valIzq)
        console.log(valDer)
        console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")*/
        if(this.operator == "+") {
            if(valIzq.type === "NUMBER" && valDer.type === "NUMBER") {
                let res = Number(valIzq.value) + Number(valDer.value);
                let resTObject =  new TObject(0,0,res,"NUMBER");
                return resTObject;
            } else if (valIzq.type === "NUMBER" && valDer.type === "STRING") {
                let res = String(valIzq.value) + String(valDer.value);
                let resTObject =  new TObject(0,0,res,"STRING");
                return resTObject;
            } else if (valIzq.type === "STRING" && valDer.type === "NUMBER") {
                let res = valIzq.value + String(valDer.value);
                let resTObject =  new TObject(0,0,res,"STRING");
                return resTObject;
            } else if (valIzq.type === "STRING" && valDer.type === "STRING") {
                let res = valIzq.value + valDer.value
                let resTObject =  new TObject(0,0,res,"STRING");
                return resTObject;
            } else if (valIzq.type === "STRING" && valDer.type === "BOOLEAN") {
                let res = valIzq.value + valDer.value
                let resTObject =  new TObject(0,0,res,"STRING");
                return resTObject;
            } else if (valIzq.type === "BOOLEAN" && valDer.type === "STRING") {
                let res = valIzq.value + valDer.value
                let resTObject =  new TObject(0,0,res,"STRING");
                return resTObject;
            } else {
                console.log("ERROR");
            }
        } else if(this.operator == "-") {
            if(valIzq.type === "NUMBER" && valDer.type === "NUMBER") {
                let res = Number(valIzq.value) - Number(valDer.value);
                let resTObject =  new TObject(0,0,res,"NUMBER");
                return resTObject;
            } else {
                console.log("ERROR");
            }
        } else if(this.operator == '*') {
            if(valIzq.type === "NUMBER" && valDer.type === "NUMBER") {
                let res = Number(valIzq.value) * Number(valDer.value);
                let resTObject =  new TObject(0,0,res,"NUMBER");
                return resTObject;
            } else {
                console.log("ERROR");
            }
        } else if(this.operator == '/') {
            if(valIzq.type === "NUMBER" && valDer.type === "NUMBER") {
                let res = Number(valIzq.value) / Number(valDer.value);
                let resTObject =  new TObject(0,0,res,"NUMBER");
                return resTObject;
            } else {
                console.log("ERROR");
            }
        } else if(this.operator == 'unary') {
            if(valIzq.type === "NUMBER") {
                let res = Number(valIzq.value) * -1;
                let resTObject =  new TObject(0,0,res,"NUMBER");
                return resTObject;
            } else {
                console.log("ERROR");
            }
        } else if (this.operator == "**") {
            if(valIzq.type === "NUMBER" && valDer.type === "NUMBER") {
                let res = Math.pow(Number(valIzq.value),Number(valDer.value));
                let resTObject =  new TObject(0,0,res,"NUMBER");
                return resTObject;
            } else {
                console.log("ERROR");
            }
        } else if (this.operator == "%") {
            if(valIzq.type === "NUMBER" && valDer.type === "NUMBER") {
                let res = Number(valIzq.value) % Number(valDer.value);
                let resTObject =  new TObject(0,0,res,"NUMBER");
                return resTObject;
            } else {
                console.log("ERROR");
            }
        } else if (this.operator == ">") {

            let opIzqVal = this.convertedValue(valIzq);
            let opDerVal = this.convertedValue(valDer);
            
            let res = opIzqVal > opDerVal;
            let resTObject =  new TObject(0,0,res,String(typeof(res)).toUpperCase());
            return resTObject;
            
        } else if (this.operator == "<") {

            let opIzqVal = this.convertedValue(valIzq);
            let opDerVal = this.convertedValue(valDer);
            
            let res = opIzqVal < opDerVal;
            let resTObject =  new TObject(0,0,res,String(typeof(res)).toUpperCase());
            return resTObject;
            
        } else if (this.operator == ">=") {

            let opIzqVal = this.convertedValue(valIzq);
            let opDerVal = this.convertedValue(valDer);
            
            let res = opIzqVal >= opDerVal;
            let resTObject =  new TObject(0,0,res,String(typeof(res)).toUpperCase());
            return resTObject;
            
        } else if (this.operator == "<=") {

            let opIzqVal = this.convertedValue(valIzq);
            let opDerVal = this.convertedValue(valDer);
            
            let res = opIzqVal <= opDerVal;
            let resTObject =  new TObject(0,0,res,String(typeof(res)).toUpperCase());
            return resTObject;
            
        } else if (this.operator == "==") {
           /*console.log("$$$$$$$$$$$$$$$$$$$$$")
            console.log(valIzq)
            console.log(valDer)
            console.log("$$$$$$$$$$$$$$$$$$$$$")*/
            let opIzqVal = this.convertedValue(valIzq);
            let opDerVal = this.convertedValue(valDer);
            let res = (opIzqVal == opDerVal);
            let resTObject =  new TObject(0,0,res,String(typeof(res)).toUpperCase());
            return resTObject;
            
        } else if (this.operator == "!=") {

            let opIzqVal = this.convertedValue(valIzq);
            let opDerVal = this.convertedValue(valDer);
            let res = (opIzqVal != opDerVal);
            let resTObject =  new TObject(0,0,res,String(typeof(res)).toUpperCase());
            return resTObject;
        } else if (this.operator == "&&") {

            let opIzqVal = this.convertedValue(valIzq);
            let opDerVal = this.convertedValue(valDer);
            let res = (opIzqVal && opDerVal);
            let resTObject =  new TObject(0,0,res,String(typeof(res)).toUpperCase());
            return resTObject;
        } else if (this.operator == "||") {
            
            let opIzqVal = this.convertedValue(valIzq);
            let opDerVal = this.convertedValue(valDer);
            let res = (opIzqVal || opDerVal);
            let resTObject =  new TObject(0,0,res,String(typeof(res)).toUpperCase());
            return resTObject;
        } else if (this.operator == "!") {
            
            let opIzqVal = this.convertedValue(valIzq);
            let res = !opIzqVal;
            
            let resTObject =  new TObject(0,0,res,String(typeof(res)).toUpperCase());
            return resTObject;
        } else if (this.operator == "INC") {

            let opIzqVal = this.convertedValue(valIzq);
            let res = opIzqVal+1;
            let resTObject =  new TObject(0,0,res,String(typeof(res)).toUpperCase());
            return resTObject;

        } else if (this.operator == "DEC") {
            let opIzqVal = this.convertedValue(valIzq);
            let res = opIzqVal-1;
            
            let resTObject =  new TObject(0,0,res,String(typeof(res)).toUpperCase());
            return resTObject;
        }
    }

}

Operation.prototype.convertedValue = function(value) {
    /*console.log("-----------------Adentro de convertedValue-----------")
    console.log(value)
    console.log(":::::::::::::::::::::::::::::::::::::::::::::::::::::")*/
    if(value) {
        if (value.type == "NUMBER") {
            return Number(value.value);
        } else if (value.type == "STRING") {
            return String(value.value);
        } else if (value.type == "BOOLEAN") {
            if(typeof(value.value) == "string") {
                if(value.value == "true")
                    return true;
                else
                    return false;
            }
            return Boolean(value.value);
        } else if(value.type == "NULL") {
            return null;
        } else if(value instanceof Map) {
            return value;
        } else if(value.type == "UNDEFINED") {
            return undefined
        }   
    }
    
    return null;
}

module.exports = Operation;

},{"./Nodo.js":18,"./TObject.js":23}],21:[function(require,module,exports){
class Scope {
    constructor(prev) {
        this.prev = prev;
        this.table = new Map();
        this.functionTable = new Map();
        this.typesTable = new Map();
    }

    getTable() {
        return this.table;
    }

    getTypesTable() {
        if(this.typesTable)
            return this.typesTable;
        return null;
    }

    getFunctionTable() {
        return this.functionTable;
    }

    getGlobalScope() {
        var sc= this;

        for(sc = this;sc.prev != null;sc = sc.prev){
        }
        return sc;
    }

    changeValueVariable(id,obj) {
        this.getObjVariable(id).set(id,obj);
    }

    getObjVariable(id) {
        var sc= this;

        for(sc = this;sc != null;sc = sc.prev){
            if(sc.table.has(id)) {
                return sc.table;
            }
        }
        return null;
    }

    getNumOfScope() {
        var sc= this;
        var num = 0;
        for(sc = this;sc != null;sc = sc.prev){
            num++;
        }
        return num;
    }

    grapah_ts() {
        var sc= this;
        let str = "";
        let types = "";
        let func = "";
        let scopeNum = this.getNumOfScope()
        for(sc = this;sc != null;sc = sc.prev){
            scopeNum--;
            str += this.graph_tsVariables(sc.table,scopeNum);
            //console.log(sc.table)
            /*if(sc.prev == null) {
                console.log(this.functionTable)
                types = this.getTypes(this.typesTable)
                func = this.getFunctions(this.functionTable)
            }*/
            
        }

        func = "Funciones \n--------------------\n" + this.getFunctions(this.getGlobalScope().functionTable);
        types = this.getTypes(this.getGlobalScope().typesTable);
        return types + "\n" + func + "\n" + str;
    }

    getTypes(types) {
        var str = "";
        for(let obj of types) {
            str += obj[0] + "   |   "
            //str += obj[1].type +"  |" 
            str += "\n";
            //str += ambito
        }
        return str+"\n";
    }

    getFunctions(funcTable) {
        var str = "";
        for(let obj of funcTable) {
            str += obj[0] + "   |   "
            //str += obj[1].type +"  |" 
            str += "\n";
            //str += ambito
        }
        return str+"\n";

    }

    graph_tsVariables(table,scopeNum) {
        
        var str = "----------------------------\n";
        for(let obj of table) {
            str += obj[0] + "   |   "
            str += obj[1].type +"  |    " 
            str += scopeNum +"  |" 
            str += "\n";
            //str += ambito
        }
        return str+"\n";

    }

    getStrArr(obj) {
        var str = "["
        var prop = "";
        //console.log(obj)
        obj.forEach((value) => {

            //prop += tab + "\t"+ key + ": ";
            if(value.constructor.name == "TObject") {
                prop += value.value;
            } else if(value.isArray) {
                prop += this.getStrArr(value.value)
            } else if(value.constructor.name == "Map"){
                prop += this.getStrObj(value,"\t");
            }
            prop += ",";
        });
        prop = prop.substring(0,prop.length-1)
        str += prop;
        str += "]"
        return str;
    }

    getStrObj(obj,tab) {
        var str = tab+"{\n"
        var prop = "";
        obj.forEach((value,key) => {

            prop += tab + "\t"+ key + ": ";
            if(value.constructor.name == "TObject") {
                prop += value.value;
            } else if(value.isArray) {
                prop += this.getStrArr(value.value)
            } else if(value.constructor.name == "Map"){
                prop += this.getStrObj(value,"\t");
            }
            prop += ",\n";
        });
        prop = prop.substring(0,prop.length-2)
        str += prop;
        str += "\n"
        str += tab +"}"
        return str;
    }

    print() {
        var sc= this;

        for(sc = this;sc != null;sc = sc.prev){
            console.log(sc.table)
            
        }
        
    }


    findVariable(id) {
        var sc= this;

        for(sc = this;sc != null;sc = sc.prev){
            if(sc.table.has(id)) {
                return sc.table.get(id);
            }
        }
        return null;
    }

    getFunction(id) {
        var sc= this;

        for(sc = this;sc != null;sc = sc.prev){
            if(sc.prev == null) {
                return sc.functionTable.get(id)
            }
        }
    }

    checkFunction(id) {
        var sc= this;

        for(sc = this;sc != null;sc = sc.prev){
            if(sc.prev == null) {
                return sc.functionTable.has(id)
            }
        }
        return false;
        //return this.functionTable.has(id);
    }

    insertFunction(id,obj) {
        
        if(!this.checkFunction(id)) {
            this.functionTable.set(id,obj);
            return true;
        } 
        return false;
    }

    existsLocalVariable(id) {
        return this.table.has(id);
    }
    
    insertVariable(id,value) {
        
        if(!this.existsLocalVariable(id)) {
            this.table.set(id,value);
            return true;
        } 
        console.log("ERROR la variable " + id + " ya existe")
        return false;
    }

    findType(id) {
        var sc= this;

        for(sc = this;sc != null;sc = sc.prev){
            if(sc.prev == null) {
                return sc.typesTable.has(id)
            }
        }
        return false;
    }

    existsType(id) {
        return this.typesTable.has(id)
    }

    insertType(id,value) {
        if(!this.existsType(id)) {
            this.typesTable.set(id,value);
        } else {

           if(this.typesTable.get(id) == null) {
                this.typesTable.delete(id);
                this.typesTable.set(id,value);
                return;
            }

            //ERROR

        }
        
    }
/*
    get existLocalVariable(id) {

    }

    set insertVariable(id,obj,byval) {

    }

    get searchVariable(id) {

    }
    
    get getObjectVariable(id) {

    }

    get existVariable(id) {

    }

    get existVariableNoGlobal(id) {

    }

    set changeVariableValue(id, nodeValue, byval) {

    }

    set insertFunction(id,obj) {

    }

    get searchFunction(id) {

    }

    get existFunction(id) {
        
    }

    get globalScope() {

    }*/
}
module.exports = Scope;
},{}],22:[function(require,module,exports){
const Scope = require('./Scope');
class Switch {

    constructor(cond,firstcase,lastcase) {
        this.cond = cond;
        this.firstcase = firstcase;
        this.lastcase = lastcase;
    }

    run(scope,console) {

        //this.cond.run(scope);

        if(this.firstcase != null) {
            var aux = this.firstcase.run(scope,this.cond,console);
            if(aux != null) {
    
                if(aux.type == 'RETURN') {
                    return aux;
                } else if(aux.type == 'BREAK') {
                    return null;
                } else if(aux.type == 'CONTINUE') {
                    return aux;
                }
            }
        }

        if(this.lastcase != null) {
            var aux = this.lastcase.run(scope,this.cond,console);
            if(aux != null) {
    
                if(aux.type == 'RETURN') {
                    return aux;
                } else if(aux.type == 'BREAK') {
                    return null;
                } else if(aux.type == 'CONTINUE') {
                    return aux;
                }
            }
        }
    }
}

module.exports = Switch;
},{"./Scope":21}],23:[function(require,module,exports){
const Nodo = require('./Nodo.js');
class TObject extends Nodo{

    constructor(line,column,value,type) {
        super(line,column,value);
        this.type = type;
        this.isArray = false;
        this.dimentions = 0;
    }

    run(scope,console) {
        return this;
    }
}
module.exports = TObject;
},{"./Nodo.js":18}],24:[function(require,module,exports){
const typeList = require("./typeList");

class Type {

    constructor(type,list) {
        this.type = type;
        this.list = list;
    }

    run(scope,console) {
        
        if(this.checkType(this.type)) {
            
            if(this.list != null) {
                let dim = this.list.run(scope,console);
                let isArray = dim==0?false:true;

                return {type:this.type,isArray:isArray,dim:dim}
            } 

            return {type:this.type,isArray:false,dim:0}
        } else {
            //buscar si el type existe
            if(scope.findType(this.type)) {
                //***EJECUTAR this.list
                //***validar this.list
                if(this.list != null) {
                    let dim = this.list.run(scope,console);
                    let isArray = dim==0?false:true;
    
                    return {type:this.type,isArray:isArray,dim:dim}
                } 
                return {type:this.type,isArray:false,dim:0}

            } else {

                //ERROR
                console.log("ERROR en Type.js")
            }
        }
    }

    checkType(t) {
        if(t == "NUMBER") {
            return true;
        } else if(t == "BOOLEAN") {
            return true;
        } else if(t == "STRING") {
            return true;
        } else if(t == "VOID") {
            return true;
        }
        return false;
    }
}

module.exports = Type;
},{"./typeList":43}],25:[function(require,module,exports){
const Nodo = require('./Nodo.js');
class Variable extends Nodo{
    
    constructor(line,column,type,id,deflast,defvarLast) {
        super(line,column,id)
        this.type = type;
        this.id = id;
        this.deflast = deflast;
        this.defvarLast = defvarLast;
    }

    run(scope,console) {

        var def = null;
        if(this.deflast !=null) {
            def = this.deflast.run(scope,this.type,console);
        }
        scope.insertVariable(this.id,def);

        if(this.defvarLast != null) {

            var list = this.defvarLast.run(scope,this.type,console);

            if(list.length > 0) {
                list.forEach(element => {
                    element.run(scope,console);
                });
            }
        }
    }
}

module.exports = Variable;
},{"./Nodo.js":18}],26:[function(require,module,exports){
const Scope = require('./Scope.js') 
class While {

    constructor(cond,stmt) {
        this.cond = cond;
        this.stmt = stmt;
    }
    
    run(scope,console) {
        var auxCond = this.cond.run(scope,console);
        if(auxCond.type == 'BOOLEAN') {

            auxCond = Boolean(auxCond.value);
            var actualScope = new Scope(scope);
            while(auxCond) {

                var newScope = new Scope(actualScope);

                var r = null;
                if(this.stmt!= null) {
                    for(var i = 0;i<this.stmt.length;i++) {
                        var element = this.stmt[i];
                        var aux = element.run(newScope,console);
                        if(aux != null) {
            
                            if(aux.type == 'RETURN') {
                                r= aux;
                                break;
                            } else if(aux.type == 'BREAK') {
                                r = aux;
                                break;
                            } else if(aux.type == 'CONTINUE') {
                                r = null;
                                break;
                            }
                        }
                    }     
                }

                if(r != null) {
                    if(r.type == 'RETURN') {
                        return r;
                    } else if(r.type == 'BREAK') {
                        break;
                    }
                }

                auxCond = this.cond.run(scope,console);
                auxCond = Boolean(auxCond.value);
            }

        } else {
            //ERROR
            console.log("ERROR en while.js")
        }
    }

    statement(scope,console) {
        if(this.stmt!= null) {
            for(var i = 0;i<this.stmt.length;i++) {
                var element = this.stmt[i];
                var aux = element.run(scope,console);
                if(aux != null) {
    
                    if(aux.type == 'RETURN') {
                        return aux;
                    } else if(aux.type == 'BREAK') {
                        return aux;
                    } else if(aux.type == 'CONTINUE') {
                        return;
                    }
                }
            }     
        }
    }
}
module.exports = While;
},{"./Scope.js":21}],27:[function(require,module,exports){
const TObject = require('./TObject.js');
class asignLast {

    constructor(list,asignLastF) {
        this.list = list;
        this.asignLastF = asignLastF;
    }

    run(scope,obj, console) {

        if(this.list != null) {

            var l = this.list.get(scope,console);
            //comprobar tipos y si es arreglo tamaños
            var fobj=obj.value;
            
            if(obj instanceof Map) {
                fobj = obj
            }

            /*console.log("||||||||  Aqui estoy al inicio de asignLast    ||||||||||")
            console.log(obj)
            console.log(l)

            console.log("|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||")
            */

            l.forEach(element => {
                if(element.isArray) {
                    if(fobj.isArray) {
                        var arrP = Number(element.exp.value);
                        var objResult = fobj.value;

                        //console.log(arrP)
                        //console.log(objResult.length)
                        if(arrP < objResult.length) {
                            fobj = objResult[arrP]
                        } else {
                            //ERRROR
                            fobj = new TObject(0,0,"undefined","UNDEFINED");
                            //console.log("Error 1 en asignLast.js")
                        }

                    } else {
                        //ERROR
                        fobj = null;
                        console.log("Error 2 en asignLast.js")
                    }
                } else {
                    if(fobj.constructor.name == "Map") {

                        if(fobj.has(element.id)) {
                            fobj = fobj.get(element.id)
                        } else {
                            //Error
                            fobj = null;
                            console.log("Error 3 en asignLast.js")
                        }

                    } else {
                        //error
                        console.log("Error 4 en asignLast.js")
                        return;
                    }
                }

            });

            if(fobj != null) {
                
                if(fobj.constructor.name == "TObject") {
                    fobj = {value:fobj}
                }

                var auxR = this.asignLastF.run(scope,null,console);
                //verificar errores aqui
                fobj=obj.value;
                if(obj instanceof Map) {
                    fobj = obj
                }
                //console.log("AQUI----->")
                //console.log(obj)
                //console.log("--------")
                //console.log(this.asignLastF.exp)
                //console.log("||||||||||||||")
                //console.log(auxR)
                //console.log(fobj);
                //console.log("**********")
                l.forEach((element,index) =>{
                    if(element.isArray) {
                        if(fobj.isArray) {
                            
                            var arrP = Number(element.exp.value);
                            
                            
                            if(index + 1 == l.length) {
                            
                                
                                fobj.value[arrP] = auxR;
                            } else {
                                fobj = fobj.value[arrP]
                            }
                            
                        }
                    } else {
                        if(fobj instanceof Map) {
                            
                            if(index + 1 == l.length) {
                                fobj.set(element.id,auxR)  
                            } else {
                                fobj = fobj.get(element.id)  
                            }
                                  
                        } else {
                            console.log("cayo aqi")
                        }
                    }
                });
                //console.log(fobj);
                return obj;
            }

        } else {
            //COMPROBAR SI ES NUMBER BOOL STRING NULL
            var dectype = obj.dectype;
            //console.log(obj);
            if(this.isPrimitive(obj)) {
                var a = new TObject(0,0,obj.value.value,obj.type)
                var obr = this.asignLastF.run(scope,{value:a},console);
                return {value:obr,type:obr.type,isArray:obr.isArray,dim:obr.dimentions,dectype:dectype}
        
            } 
            var obr = this.asignLastF.run(scope,obj,console);
            //console.log(obr)
            obr.dectype = dectype;
            obr.type = obj.type;
            return obr;
        }
    }

    isPrimitive(obj) {
        switch(obj.type) {
            case 'NUMBER':
                return true;
            case 'BOOLEAN':
                return true;
            case 'STRING':
                return true;
            case 'NULL':
                return true;
            case 'UNDEFINED':
                return true
            default:
                return false;    
        }
    }
}

module.exports = asignLast;
},{"./TObject.js":23}],28:[function(require,module,exports){
const Operation = require('./Operation.js')
const TObject   = require('./TObject.js') 
class asignLastF {

    constructor(op,exp) {
        this.op = op;
        this.exp = exp;
    }

    run(scope,obj,console) {

        if(this.op == null) {
            return this.exp.run(scope,console);
        }

        if(this.exp != null) {

            //hacer comprobacion de tipos
            //var newObject = new TObject(0,0,obj.value.value,obj.type)
            
            var operation = new Operation(0,0,obj.value,this.exp,this.op);
            //console.log(operation);
            return operation.run(scope,console);

        } else {
            var newObject = new TObject(0,0,"1","NUMBER")
            var operation = new Operation(0,0,obj.value,newObject,this.op);
            return operation.run(scope,console);
        }
    }

    
}

module.exports = asignLastF;
},{"./Operation.js":20,"./TObject.js":23}],29:[function(require,module,exports){
class asignVariable {

    constructor(id,asignLast) {
        this.id = id;
        this.asignLast = asignLast;
    }

    run(scope, console) {

        var objId = scope.findVariable(this.id);
        if(objId != null) {
            
            

            var res = this.asignLast.run(scope,objId,console);
            if(this.id == 'pivot'){
                console.log(objId);
                console.log("&&&&&&&&&&&")
                console.log(res)
            }
            //console.log("/**********Aqui estoy en run()************************/");
            ///console.log("/**********************************/");
         ///console.log("/**********************************/");
         ///console.log(this.id)
         //console.log(res.value)
        //console.log("/**********************************/");
        //console.log("/**********************************/");
        //console.log("/**********************************/");
            scope.changeValueVariable(this.id,res);

        } else {
            console.log("Error 1 en asigVariable.js")
        }
    }

    get(scope,globalScope, console) {

        var objId = scope.findVariable(this.id);
        if(objId != null) {
            //comprobar si res es null
            /*console.log(this.id)
            console.log(objId)
            console.log("%%%%%%%%%%")*/
            var res = this.asignLast.run(globalScope,objId, console);
            //console.log("/**********Aqui estoy en get()************************/");
           // console.log("/**********************************/");
         //console.log("/**********************************/");
         //console.log(this.id)
         //console.log(res)
        //console.log("/**********************************/");
        //console.log("/**********************************/");
        //console.log("/**********************************/");
        
            scope.changeValueVariable(this.id,res);

        } else {
            console.log("Error 2 en asigVariable.js")
        }
    }
}
module.exports = asignVariable;
},{}],30:[function(require,module,exports){
const Nodo = require('./Nodo.js');
const TObject = require('./TObject.js');
const Scope = require('./Scope.js');
const Variable = require("./Variable");
const defLast = require("./defLast");
const idVarlast = require("./idVarlast");

const asignVariable = require('./asignVariable.js');
const asignLast = require("./asignLast");
const asignLastF = require("./asignLastF");

class callFunction extends Nodo{
    constructor(line, column,id,idList,params) {
        super(line,column,null);
        this.id = id;
        this.idList = idList;
        this.params = params;
        this.stmt = null;
    }

    run(scope,consoleT) {
        
        if(this.id == "console") {
            
            if(this.idList != null) {

                var list = this.idList.run(scope,consoleT);
                if(list.id == "log" && list.aux == null) {
                    if(this.params != null) {
                        //console.log(this.params)
                        if(this.params.length == 1) {
                            let tobj = this.params[0];
                            //console.log("----------------------");
                            let newTObj = tobj.run(scope,consoleT);
                            //console.log(newTObj);
                            //console.log(tobj)
                            if(newTObj.constructor.name == "Map") {
                                
                                if(consoleT) {
                                    consoleT.value += this.getStrObj(newTObj,"") + "\n";
                                }

                                console.log(this.getStrObj(newTObj,""));
                                
                            } else if(newTObj.isArray) {
                                /*console.log("########")
                                console.log(newTObj)
                                console.log("######################")*/
                                if(consoleT) {
                                    consoleT.value += this.getStrArr(newTObj.value) + "\n";
                                }
                                console.log(this.getStrArr(newTObj.value));
                            }else {
                                if(consoleT) {
                                    consoleT.value += newTObj.value.toString() + "\n";
                                }
                                console.log(newTObj.value.toString());
                            }

                        } else {
                            let str = "";
                            for (let i = 0; i < this.params.length; i++) {
                                let tobj = this.params[i];
                                //console.log("----------------------");
                                let newTObj = tobj.run(scope,consoleT);
                                //console.log(newTObj);
                                //console.log(tobj)
                                if(newTObj.constructor.name == "Map") {
                                    
                                    str += this.getStrObj(newTObj,"")+" ";
                                    
                                } else if(newTObj.isArray) {
                                    /*console.log("########")
                                    console.log(newTObj)
                                    console.log("######################")*/
                                    str += this.getStrArr(newTObj.value)+" ";
                                }else {
                                    str += newTObj.value.toString()+" ";
                                }
                                
                            }
                            if(consoleT) {
                                consoleT.value += str + "\n";
                            }
                            console.log(str);

                            /*new Error(this.params.line,
                                this.params.column,
                                "Semantico",
                                "Error la funcion necesita un parametro");
                                console.log("Error 1 en callFunction.js")*/
                        }
                    } else {
                        new Error(this.params.line,
                                this.params.column,
                                "Semantico",
                                "Error la funcion necesita un parametro");
                                console.log("Error 2 en callFunction.js")
                    }

                } else {
                    console.log("No se qe va aqui callFunction.js")
                }

                
            } else {

                return this.runFunction(scope,consoleT);
            }
            
        } else if(this.id == "graficar_ts") {
            if(this.idList == null) {

                var a = scope.grapah_ts();
                console.log(a);

            } else {
                console.log("Error 3 en callFunction.js")
                return new TObject(0,0,"undefined","UNDEFINED");
            }
        } else {
            if(this.idList != null) {
                var arr = scope.findVariable(this.id);
                
                if(arr) {
                    
                    var list = this.idList.get(scope,consoleT);    
                    if(list.length == 1) {
                        
                        if(arr.isArray && list[0].id) {
                            if(list[0].id == 'pop') {
                                console.log("pop")
                                return this.pop(scope,arr.value,consoleT)
                            } else if(list[0].id == 'push') {
                                var isSimple = true;
                                return this.push(scope,arr,isSimple,consoleT)
                            }
                        }

                    } else if(list.length > 1){

                        var lastItem = list.pop();
                        var array = new idVarlast(0,0,this.id,list);
                        array = array.get(scope,list,consoleT);

                        if(array.isArray) {
                            if(lastItem.id == 'pop') {
                                return this.pop(scope,array,consoleT)
                            } else if(lastItem.id == 'push') {
                                var isSimple = false;
                                return this.push(scope,array,isSimple,consoleT)
                            }
                        }
                    }
                        
                   
                }
                
                console.log("Error 4 en callFunction.js")
                var undef = new TObject(0,0,"undefined","UNDEFINED");
                return undef.run(scope,consoleT);
                

            } else {
                return this.runFunction(scope,consoleT);
            }
        }
    }

    push(scope,arr,isSimple,consoleT) {
        //comprobar tipos de matriz
        if(this.params) {
            if(this.params.length == 1) {
                var tobj = this.params[0];
                tobj = tobj.run(scope,consoleT);
                //verificar si el parametro del push es compatible con arr
                if(isSimple) {
                    arr.value.value.push(tobj);
                } else {
                    arr.value.push(tobj);
                }

            } else {
                console.log("Error 5 en callFunction.js")
            }
        } else {
            //ERROR
            console.log("Error 6 en callFunction.js")
        }
        var undef = new TObject(0,0,"undefined","UNDEFINED");
        return undef.run(scope,consoleT);
    }

    pop(scope,arr,consoleT) {

        if(arr.value.length > 0) {
            return arr.value.pop();
        }
        var undef = new TObject(0,0,"undefined","UNDEFINED");
        return undef.run(scope,consoleT);
    }


    runFunction(scope,consoleT) {
        
        if(scope.checkFunction(this.id)) {

            return this.func(scope,consoleT);

        } else {
            //error
            console.log("Error 7 en callFunction.js")
            /*console.log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
            console.log(this.id)
            console.log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");*/
            var undef = new TObject(0,0,"undefined","UNDEFINED");
            return undef.run(scope,consoleT);
        }

    }

    func(scope,consoleT) {

        var funcObj = scope.getFunction(this.id);
        //console.log(funcObj)
        this.stmt = funcObj.stmt;
        var functionScope = new Scope(scope);
        
        for (let param of funcObj.param) {
            var asgn = new Variable(0,0,'let',param.id,new defLast(0,0,param.types,new TObject(0,0,"null",'NULL')),null);
            //var asgn = new Variable(0,0,'let',param.id,new defLast(0,0,param.types,new TObject(0,0,"undefined",'UNDEFINED')),null);
            
            asgn.run(functionScope,consoleT);
        }

        /*console.log(this.id)
        console.log(funcObj)
        console.log(this.params)*/
        
        if(this.params == null) {
            if(!funcObj.param.length == 0) {
                console.log("Error 0.8 en callFunction.js")
                console.log("ERROR en la cantidad de parametros")
            }
        } else {
            if(funcObj.param.length == this.params.length) {
                //comprobar tipos
                //console.log(funcObj.param)
                //console.log(this.params)
                for (let param in this.params) {
                    var changeValue = new asignVariable(funcObj.param[param].id,new asignLast(null,new asignLastF(null,this.params[param])));
                    changeValue.get(functionScope,scope,consoleT);
                }
            } else {
                console.log("Error 8 en callFunction.js")
                console.log("ERROR en la cantidad de parametros")
            }
        }

        
        //functionScope.print()
        //console.log("--------------------------------")
        /****DEBUG */

        

        /********* */

        functionScope.prev = scope.getGlobalScope();

        var aux = this.statement(functionScope,consoleT);
        if(aux != null) {
    
            if(aux.type == 'RETURN') {
                return aux.res;
            } 
        }

        var undef = new TObject(0,0,"undefined","UNDEFINED");
        return undef.run(scope,consoleT);
    }

    statement(scope,consoleT) {
        if(this.stmt!= null) {
            for(var i = 0;i<this.stmt.length;i++) {
                var element = this.stmt[i];
                var aux = element.run(scope,consoleT);
                //console.log(aux)
                if(aux != null) {
    
                    if(aux.type == 'RETURN') {
                        return aux;
                    } 
                }
            }     
        }
        return null;
    }

    getStrArr(obj) {
        var str = "["
        var prop = "";
        //console.log(obj)
        obj.forEach((value) => {

            //prop += tab + "\t"+ key + ": ";
            if(value.constructor.name == "TObject") {
                prop += value.value;
            } else if(value.isArray) {
                prop += this.getStrArr(value.value)
            } else if(value.constructor.name == "Map"){
                prop += this.getStrObj(value,"\t");
            }
            prop += ",";
        });
        prop = prop.substring(0,prop.length-1)
        str += prop;
        str += "]"
        return str;
    }

    getStrObj(obj,tab) {
        var str = tab+"{\n"
        var prop = "";
        obj.forEach((value,key) => {

            prop += tab + "\t"+ key + ": ";
            if(value.constructor.name == "TObject") {
                prop += value.value;
            } else if(value.isArray) {
                prop += this.getStrArr(value.value)
            } else if(value.constructor.name == "Map"){
                prop += this.getStrObj(value,"\t");
            }
            prop += ",\n";
        });
        prop = prop.substring(0,prop.length-2)
        str += prop;
        str += "\n"
        str += tab +"}"
        return str;
    }
}

module.exports = callFunction;
},{"./Nodo.js":18,"./Scope.js":21,"./TObject.js":23,"./Variable":25,"./asignLast":27,"./asignLastF":28,"./asignVariable.js":29,"./defLast":32,"./idVarlast":37}],31:[function(require,module,exports){
class decType {

    constructor(id,obj) {
        this.id = id;
        this.obj = obj;
    }

    run(scope,console) {
        //comprobar si el type ya existe
        //comprobar si las propiedades del type no estan repetidas
        
        scope.insertType(this.id,null);

        var ob = this.obj.run(scope,console)

        scope.insertType(this.id,ob);
    }

}

module.exports = decType;
},{}],32:[function(require,module,exports){
const Nodo = require('./Nodo.js');
const TObject = require('./TObject.js');
class defLast extends Nodo{

    constructor(line,column,type,exp) {
        super(line,column,null);
        this.type = type;
        this.exp = exp;
    }

    run(scope,decType,console) {
        /*falta validar que si no tiene :type la variable
          no se puede asignar un objeto
        */
        let e = null;
        let type = "NULL";
        let isArray = false;
        let dimention = 0;
    
        if(this.exp) {
            e = this.exp.run(scope,console);
            if(e){
               /* console.log("---------------")
                console.log(this.exp)
                console.log("---------------")*/
                type = e.type;
                isArray = e.isArray;
                dimention = e.dimentions;
            } else {
                e = new TObject(0,0,"null","NULL")
                type = "NULL"
                isArray = false;
                dimention = 0;
            }
        }

        if(this.type != null) {
            
            let tType = this.type.run(scope,console);
            //comprobar si exp == tType

            if(e.type != 'NULL') {

                if(e.isArray) {

                    //***Comprobar si todos los elementos del arreglo son iguales
                    //**Comprobar si los dos son arreglos de la misma dimencion */
                    
                    return {value:e,type:e.type,isArray:e.isArray,dim:tType.dim,dectype:decType}

                    
                } else if(e.type == "OBJ") {
                    
                    //1.0**evaluar que las propiedades del TYPE 
                    //1.1-**sean igual al TYPE en TS
                    //coprobar los valores de las propiedades
                    
                    return {value:e.value,type:tType.type,isArray:tType.isArray,dim:tType.dim,dectype:decType}

                }else {

                    if(e.type == tType.type) {
                        return {value:e,type:tType.type,isArray:tType.isArray,dim:tType.dim,dectype:decType}
                    } else {
                        console.log("Error 1 en defLast.js")
                        console.log("tipos incompatibles")
                        
                        return null;
                    }

                }

            }

            return {value:e,type:tType.type,isArray:tType.isArray,dim:tType.dim,dectype:decType}
 
        } 

        return {value:e,type:type,isArray:isArray,dim:dimention,dectype:decType}
        
    }
}

module.exports = defLast;
},{"./Nodo.js":18,"./TObject.js":23}],33:[function(require,module,exports){
class defVarLast {
    
    constructor(defVarLastP) {
        this.defVarLastP = defVarLastP;
    }

    run(scope,decType) {
        return this.defVarLastP.run(scope,decType,console);
    }

}

module.exports = defVarLast;
},{}],34:[function(require,module,exports){
const Variable = require('./Variable.js');
class defVarLastP {

    constructor(line,column,list,id,deflast) {
        this.line = line;
        this.column = column;
        this.list = list;
        this.id = id;
        this.deflast = deflast;        
    }

    run(scope,decType,console) {


        if(this.list != null) {

            var l = this.list.run(scope,decType,console);
            var aux = new Variable(this.line,this.column,decType,this.id,this.deflast,null);
            l.push(aux);
            return l;
        } else {
            var aux = new Variable(this.line,this.column,decType,this.id,this.deflast,null);

            return [aux];
        }
    }
}

module.exports = defVarLastP;
},{"./Variable.js":25}],35:[function(require,module,exports){
const Scope = require('./Scope.js') 
class doWhile {

    constructor(cond,stmt) {
        this.cond = cond;
        this.stmt = stmt;
    }

    run(scope,console) {
        
        var auxCond = this.cond.run(scope,console);
        if(auxCond.type == 'BOOLEAN') {

            auxCond = Boolean(auxCond.value);
            var actualScope = new Scope(scope);

            do {

                var newScope = new Scope(actualScope);
                var r = this.statement(newScope,console)

                if(r != null && r != undefined) {
                    if(r.type == 'RETURN') {
                        return r;
                    } else if(r.type == 'BREAK') {
                        //return r;
                        break;
                    }
                }

                auxCond = this.cond.run(scope,console);
                auxCond = Boolean(auxCond.value);

            } while(auxCond);

        } else {
            //ERROR
            console.log("Error 1 en doWhile.js")
        }

    }

    statement(scope,console) {
        if(this.stmt!= null) {
            for(var i = 0;i<this.stmt.length;i++) {
                var element = this.stmt[i];
                var aux = element.run(scope,console);
                if(aux != null) {
    
                    if(aux.type == 'RETURN') {
                        return aux;
                    } else if(aux.type == 'BREAK') {
                        return aux;
                    } else if(aux.type == 'CONTINUE') {
                        return null;
                    }
                }
            }     
        }
    }
}

module.exports = doWhile;
},{"./Scope.js":21}],36:[function(require,module,exports){
class idList {

    constructor(isArray,expOrID,auxp) {
        this.isArray = isArray;
        this.expOrID = expOrID;
        this.auxp = auxp;
    }
    //para funciones
    run(scope,console) {

        var aux = null;

        if(this.auxp != null) {
            aux = this.auxp.run(scope,console);
        }

        if(this.isArray) {

            let exp = this.expOrID.run(scope,console);
            

        } else {

            return {id:this.expOrID,auxP:aux}
            
        }
    }

    get(scope,console) {
        if(this.isArray) {

            let exp = this.expOrID.run(scope,console);
            
            if(exp.type != "NULL") {
                
                var aux = null;

                if(this.auxp != null) {
                    aux = this.auxp.get(scope,console);
                    let r = [];
                    r.push({isArray:true,exp:exp,id:null });
                    aux.forEach(element => {
                        r.push(element);
                    });
                    return r;
                }
                return [{isArray:true,exp:exp,id:null }]

            } else {
                //ERROR
                console.log("Error 1 en idList.js")
            }
            
        } else {
            var aux = null;
            if(this.auxp != null) {
                aux = this.auxp.get(scope,console);
                let r = [];
                r.push({isArray:false,exp:null,id:this.expOrID });
                aux.forEach(element => {
                    r.push(element);
                });
                return r;
            }
            return [{isArray:false,exp:null,id:this.expOrID }]
        }
    }
}   

module.exports = idList;
},{}],37:[function(require,module,exports){
const TObject = require('./TObject.js');
class idVarlast {

    constructor(line,column,id,varlast) {
        this.id = id;
        this.varlast = varlast;
    }

    get(scope,l,console) {
        if(scope.findVariable(this.id) != null) {

            let vl = l;
            let objId = scope.findVariable(this.id);

            var vobj = objId.value;
            vl.forEach(element => {
                
                if(element.isArray) {
                    if(vobj.isArray) {

                        var arrP = Number(element.exp.value);
                        var objResult = vobj.value;

                        if(arrP < objResult.length) {
                            vobj = objResult[arrP]
                        } else {
                            //ERRROR
                            console.log("Error 1 en idVarlast.js")
                        }
                    } else {
                        //error
                        console.log("Error 2 en idVarlast.js")
                        return;
                    }
                } else {
                    if(vobj.constructor.name == "Map") {

                        if(vobj.has(element.id)) {
                            //console.log("CORRECTO")
                            vobj = vobj.get(element.id)
                        } else {
                            //Error
                            console.log("Error 3 en idVarlast.js")
                        }

                    } else {
                        //error
                        console.log("Error 4 en idVarlast.js")
                        return;
                    }
                }
            });
            return vobj;
            //console.log(objId)

        } else {
            /***#########ERROR###############*/
            console.log("Error 5 en idVarlast.js")
            return new TObject(0,0,'undefined',"UNDEFINED");
        }
    }

    run(scope,console) {

        if(scope.findVariable(this.id) != null) {

            let vl = this.varlast.get(scope,console);
            /*console.log("VARLAST")
            console.log(vl);
            console.log("Fin VarLAST")*/
            let objId = scope.findVariable(this.id);

            

            var vobj = objId.value;

            if(objId instanceof Map) {
                vobj = objId
            }

            /*
            console.log("||||||||  Aqui estoy al inicio de idVarlast      ||||||||||")
            console.log(vobj)
            console.log("|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||")
            */
            for(let i=0;i<vl.length;i++){
           // vl.every((element,index) => {
                var element = vl[i];
                if(i+1 == vl.length) {
                    
                    if(element.id == 'length' && vobj.isArray) {
                        var r = vobj.value.length;
                        
                        var length = new TObject(0,0,r,"NUMBER");
                        return length.run(scope,console);
                        
                    }
                }

                

                if(element.isArray) {
                    if(vobj.isArray) {

                        var arrP = Number(element.exp.value);
                        var objResult = vobj.value;
                        //console.log(arrP);
                        //console.log(objResult.length)
                        if(arrP < objResult.length) {
                            //console.log("QUE ENTRO")
                            vobj = objResult[arrP]
                            if(!vobj) {
                                vobj = new TObject(0,0,"undefined","UNDEFINED");
                            }

                        } else {
                            //ERRROR
                            console.log("Error 6 en idVarlast.js")
                        }
                    } else {
                        //error
                        console.log("Error 7 en idVarlast.js")
                        return;
                    }
                } else {

                   
                    if(vobj instanceof Map) {

                        if(vobj.has(element.id)) {
                            //console.log("CORRECTO")
                            vobj = vobj.get(element.id)
                        } else {
                            //Error
                            console.log("Error 8 en idVarlast.js")
                        }

                    } else {
                        //error
                        console.log("Error 9 en idVarlast.js")
                        /*console.log(objId)
                        console.log(vl)
                        console.log(element)
                        console.log("????????????????????????")
                        console.log(vobj)*/
                        return new TObject(0,0,'null',"NULL");;
                    }
                }
            }/*);*/
            /*console.log("aqui retorna el objeto");
            console.log(vobj)*/
            return vobj;
            //console.log(objId)

        } else {
            /***#########ERROR###############*/
            console.log("Error 10 en idVarlast.js")
            return new TObject(0,0,'undefined',"UNDEFINED");
        }
    }
}
module.exports = idVarlast;
},{"./TObject.js":23}],38:[function(require,module,exports){
class objList {

    constructor(list,key) {
        this.list = list;
        this.key = key;
    }

    run(scope,console) {

        if(this.list != null) {

            var e = this.key.run(scope,console);
            var l = this.list.run(scope,console);

            e.forEach((value, key) => l.set(key, value));

            return l;

        }

        return this.key.run(scope,console);
    }
}
module.exports = objList;
},{}],39:[function(require,module,exports){
class objProperty {

    constructor(id,exp) {
        this.id = id;
        this.exp = exp;
    }

    run(scope,console) {

        var e = this.exp.run(scope,console);
        var obj = new Map();
        obj.set(this.id,e);
        return obj;
    }
}

module.exports = objProperty;
},{}],40:[function(require,module,exports){
class objType {

    constructor(list,keyvalue) {
        this.list = list;
        this.keyvalue = keyvalue;
    }

    run(scope,console) {

        if(this.list != null) {

            var l = this.list.run(scope,console);
            var kv = this.keyvalue.run(scope,console);

            l.push(kv[0]);
            return l;
        }

        return this.keyvalue.run(scope,console);
    }
}

module.exports = objType;
},{}],41:[function(require,module,exports){
class ternaryOp {

    constructor(cond,texp,fexp) {
        this.cond = cond;
        this.texp = texp;
        this.fexp = fexp;
    }

    run(scope,console) {
        //comproba el tipo
        var c = this.cond.run(scope,console);
        if(c.type == 'BOOLEAN') {
            
            var boolCond = Boolean(c.value);
            if(boolCond) {
                return this.texp.run(scope,console);
            } else {
                return this.fexp.run(scope,console);
            }

        } else {
            //ERROR
            console.log("Error en ternaryOp.js")
        }

    }
}

module.exports = ternaryOp;
},{}],42:[function(require,module,exports){
class typeKeyValue {

    constructor(id,type) {
        this.id = id;
        this.type = type;
    }

    run(scope,console) {

        var t = this.type.run(scope,console);
        
        if(t == null) {
            //error
            console.log("Error en typeKeyValue.js")
        }

        return [{id:this.id,type:t.type}]

    }
}

module.exports = typeKeyValue;
},{}],43:[function(require,module,exports){
const Nodo = require('./Nodo.js');
class typeList extends Nodo{

    constructor(line,column,list) {
        super(line,column,null)
        this.list = list;
        this.contador = 1;
    }

    run(scope,console) {

        if(this.list != null) {
            return this.list.run(scope,console) + this.contador;
        }

        return this.contador;
    }
}

module.exports = typeList;
},{"./Nodo.js":18}],44:[function(require,module,exports){
(function (process){
/* parser generated by jison 0.4.18 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var gramatica = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,6],$V1=[1,13],$V2=[1,15],$V3=[1,16],$V4=[1,17],$V5=[1,18],$V6=[1,19],$V7=[1,20],$V8=[1,21],$V9=[1,22],$Va=[5,9,10,30,42,47,48,49,57,58,82],$Vb=[1,32],$Vc=[2,15],$Vd=[1,30],$Ve=[1,31],$Vf=[1,33],$Vg=[1,34],$Vh=[1,35],$Vi=[1,36],$Vj=[1,37],$Vk=[1,38],$Vl=[5,9,10,14,30,38,39,40,42,47,48,49,53,56,57,58,82],$Vm=[2,14],$Vn=[5,9,10,14,15,30,38,39,40,42,47,48,49,53,56,57,58,82],$Vo=[1,60],$Vp=[1,53],$Vq=[1,61],$Vr=[1,51],$Vs=[1,52],$Vt=[1,54],$Vu=[1,55],$Vv=[1,56],$Vw=[1,57],$Vx=[1,58],$Vy=[1,59],$Vz=[1,65],$VA=[15,28],$VB=[2,98],$VC=[1,72],$VD=[1,71],$VE=[1,86],$VF=[1,87],$VG=[1,88],$VH=[2,17],$VI=[1,112],$VJ=[1,113],$VK=[1,97],$VL=[1,98],$VM=[1,99],$VN=[1,100],$VO=[1,101],$VP=[1,102],$VQ=[1,103],$VR=[1,104],$VS=[1,105],$VT=[1,106],$VU=[1,107],$VV=[1,108],$VW=[1,109],$VX=[1,110],$VY=[1,111],$VZ=[5,9,10,11,14,15,25,28,30,33,38,39,40,42,47,48,49,53,56,57,58,60,61,70,77,78,82,90,91,92,93,94,95,96,97,98,99,100,101,102,103,105],$V_=[2,145],$V$=[5,9,10,11,14,15,23,25,28,30,33,38,39,40,42,47,48,49,53,56,57,58,60,61,70,73,74,75,76,77,78,82,90,91,92,93,94,95,96,97,98,99,100,101,102,103,105],$V01=[2,79],$V11=[5,9,10,14,15,25,28,30,38,39,40,42,47,48,49,53,56,57,58,70,82],$V21=[1,127],$V31=[1,135],$V41=[1,131],$V51=[1,132],$V61=[1,133],$V71=[1,134],$V81=[10,14,30,38,39,40,42,47,48,49,53,56,57,58,82],$V91=[1,154],$Va1=[1,155],$Vb1=[1,159],$Vc1=[25,28],$Vd1=[28,70],$Ve1=[1,185],$Vf1=[1,184],$Vg1=[14,15,28],$Vh1=[11,12,14,15,25,28],$Vi1=[2,105],$Vj1=[1,193],$Vk1=[10,23,69,91,104,106,107,108,109,110,111],$Vl1=[5,9,10,11,14,15,25,28,30,33,38,39,40,42,47,48,49,53,56,57,58,60,61,70,82,90,91,96,97,98,99,100,101,102,103,105],$Vm1=[5,9,10,11,14,15,25,28,30,33,38,39,40,42,47,48,49,53,56,57,58,60,61,70,82,90,91,92,93,95,96,97,98,99,100,101,102,103,105],$Vn1=[5,9,10,11,14,15,25,28,30,33,38,39,40,42,47,48,49,53,56,57,58,60,61,70,82,96,97,98,99,100,101,102,103,105],$Vo1=[1,239],$Vp1=[11,12,14,15,25,28,69],$Vq1=[1,263],$Vr1=[2,44],$Vs1=[1,277],$Vt1=[5,9,10,11,14,15,25,28,30,33,38,39,40,42,47,48,49,53,56,57,58,60,61,69,70,77,78,82,90,91,92,93,94,95,96,97,98,99,100,101,102,103,105],$Vu1=[14,53,56];
var parser = {trace: function trace () { },
yy: {},
symbols_: {"error":2,"S":3,"Bloque":4,"EOF":5,"Instruccion":6,"llamadaFuncion":7,"variables":8,"Type":9,"id":10,"igual":11,"curlyBraceOpen":12,"parsObj":13,"curlyBraceClose":14,"semicolon":15,"funciones":16,"IF":17,"WHILE":18,"DOWHILE":19,"SWITCH":20,"FOR":21,"PL":22,"bracketOpen":23,"paramFunc":24,"bracketClose":25,"varLast":26,"paramFuncList":27,"comma":28,"E":29,"function":30,"funcParam":31,"funcDec":32,"dosPuntos":33,"types":34,"STMT":35,"funcParamList":36,"InstruccionI":37,"Break":38,"Continue":39,"return":40,"OP":41,"if":42,"exp":43,"IFLAST":44,"else":45,"IFCOND":46,"while":47,"do":48,"switch":49,"FIRSTCASE":50,"LASTCASE":51,"CASE":52,"case":53,"DEFCASE":54,"ENDCASE":55,"default":56,"for":57,"let":58,"forOP":59,"in":60,"of":61,"forDec":62,"defVarLast":63,"defVarLastP":64,"defLast":65,"defType":66,"asignLast":67,"asignLastF":68,"sqBracketOpen":69,"sqBracketClose":70,"auxP":71,"point":72,"masIgual":73,"menosIgual":74,"porIgual":75,"divisionIgual":76,"increment":77,"decrement":78,"objType":79,"opkv":80,"keyvalueT":81,"const":82,"number":83,"typesList":84,"boolean":85,"string":86,"void":87,"typesL":88,"objetoParam":89,"mas":90,"menos":91,"por":92,"division":93,"potencia":94,"modulo":95,"mayorque":96,"menorque":97,"mayorigualque":98,"menorigualque":99,"igualdad":100,"diferencia":101,"and":102,"or":103,"not":104,"question":105,"NUMBER":106,"STRING":107,"true":108,"false":109,"null":110,"undefined":111,"arrParam":112,"sqBCKFIN":113,"sqBckList":114,"listArrParam":115,"objetoParamList":116,"keyvalue":117,"$accept":0,"$end":1},
terminals_: {2:"error",5:"EOF",9:"Type",10:"id",11:"igual",12:"curlyBraceOpen",14:"curlyBraceClose",15:"semicolon",23:"bracketOpen",25:"bracketClose",28:"comma",30:"function",33:"dosPuntos",38:"Break",39:"Continue",40:"return",42:"if",45:"else",47:"while",48:"do",49:"switch",53:"case",56:"default",57:"for",58:"let",60:"in",61:"of",69:"sqBracketOpen",70:"sqBracketClose",72:"point",73:"masIgual",74:"menosIgual",75:"porIgual",76:"divisionIgual",77:"increment",78:"decrement",82:"const",83:"number",85:"boolean",86:"string",87:"void",90:"mas",91:"menos",92:"por",93:"division",94:"potencia",95:"modulo",96:"mayorque",97:"menorque",98:"mayorigualque",99:"menorigualque",100:"igualdad",101:"diferencia",102:"and",103:"or",104:"not",105:"question",106:"NUMBER",107:"STRING",108:"true",109:"false",110:"null",111:"undefined"},
productions_: [0,[3,2],[4,2],[4,1],[6,1],[6,1],[6,7],[6,1],[6,1],[6,1],[6,1],[6,1],[6,1],[7,6],[22,1],[22,0],[24,1],[24,0],[27,3],[27,1],[16,6],[32,5],[32,3],[31,1],[31,0],[36,5],[36,3],[35,2],[35,1],[37,1],[37,1],[37,1],[37,1],[37,1],[37,1],[37,1],[37,1],[37,2],[37,2],[37,2],[41,2],[41,1],[17,8],[44,2],[44,0],[46,8],[46,3],[18,7],[19,9],[20,8],[50,1],[50,0],[52,5],[52,4],[51,2],[54,3],[55,1],[55,0],[21,14],[21,13],[21,11],[21,10],[21,9],[59,1],[59,1],[62,1],[62,1],[63,2],[63,0],[64,4],[64,2],[8,5],[8,3],[8,2],[67,2],[67,1],[26,4],[26,3],[71,1],[71,0],[68,2],[68,2],[68,2],[68,2],[68,2],[68,1],[68,1],[13,1],[13,0],[79,3],[79,1],[80,1],[80,1],[81,3],[66,1],[66,1],[65,4],[65,2],[65,0],[34,2],[34,2],[34,2],[34,2],[34,2],[84,1],[84,0],[88,3],[88,2],[29,1],[29,3],[43,3],[43,3],[43,3],[43,3],[43,2],[43,3],[43,3],[43,3],[43,3],[43,3],[43,3],[43,3],[43,3],[43,3],[43,3],[43,2],[43,3],[43,5],[43,2],[43,2],[43,1],[43,1],[43,1],[43,1],[43,1],[43,1],[43,2],[43,1],[43,5],[43,4],[113,1],[113,0],[114,4],[114,3],[112,1],[112,0],[115,3],[115,1],[89,1],[89,0],[116,3],[116,1],[117,3]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
 return {ast:$$[$0-1],inner:functionTable}; 
break;
case 2: case 27:
 $$[$0-1].push($$[$0]); this.$=$$[$0-1];
break;
case 3: case 28:
 this.$ = [$$[$0]]; 
break;
case 4: case 5: case 8: case 9: case 10: case 11: case 12: case 14: case 23: case 32: case 33: case 34: case 35: case 36: case 50: case 56: case 63: case 64: case 65: case 66: case 75: case 94: case 95: case 104: case 108: case 140: case 144: case 147: case 148: case 151:
 this.$ = $$[$0]; 
break;
case 6:
 this.$ = new declaracionTypes($$[$0-5],$$[$0-2]); 
break;
case 7:
 
				/*callFunc = [];
				aux = funcList.length != 0?funcList.join('\n'):"";
				funcList = [];*/
				//ESTO NO
				/*console.log(chalk.blue("este es en func------"))
				console.log(chalk.blue(aux))*/
				/*for(let a in table)
					console.log(table[a]);
				console.log("------------------------------------");*/
				/*this.$ = $$[$0] + "\n"+aux; 
				aux = "";*/

				this.$ = $$[$0];
			
break;
case 13:
 
	this.$ = new tLlamadaFunciones($$[$0-5],$$[$0-4],$$[$0-2],";");

break;
case 15:
 this.$ = null 
break;
case 16: case 87: case 90: case 91: case 92:
this.$ = $$[$0];
break;
case 17: case 88: case 145:
this.$ = null;
break;
case 18:
this.$ = new paramFuncList($$[$0-2],$$[$0]);
break;
case 19:
this.$ = new paramFuncList(null,$$[$0]);
break;
case 20:
 
			   
			   /*for(let i =0;i<callFunc.length;i++) {
				   $$[$0] = String($$[$0]).replace(callFunc[i].id,callFunc[i].new_id);
			   }
				
			   this.$ = $$[$0-5] + " " + $$[$0-4] + $$[$0-3] + $$[$0-2] + $$[$0-1] + $$[$0];*/
			   /*var a6 = $$[$0].tree
			  	if($$[$0].inner != undefined) {
					  functionTable.push({parent:$$[$0-4],function:$$[$0]});
				}*/	
				if(auxTable.length != 0) {
					for(var i in auxTable) {
						functionTable.push({parent:$$[$0-4],func:auxTable[i]});
					}
					auxTable = [];
				}
			   this.$ = new translateFunction($$[$0-4],$$[$0],$$[$0-2]);
			   
			
break;
case 21:
 
			/*console.log(chalk.green("FUNCION"));*/
			//s = eval('$$');
			var f = eval('$$');
			//console.log(chalk.red("LA PILA"))
			var value;
			var index = 0;
			var parentId = f[2];
			for(let i in f) {
				if(Array.isArray(f[i])) {
					value = f[i];
				}
			}
			if(index != 0) {
				//console.log(chalk.blue(f[index]));
			}
			//console.log(chalk.red("-----------------------"))
			var listStmt = [];
			var innerFunctions = [];
			for(let i in value) {
				//console.log(value[i])
				if(value[i].constructor.name == "translateFunction")
					auxTable.push(value[i])
				else
					listStmt.push(value[i]);
				//console.log(chalk.green("#########"));
			}
			//console.log(chalk.red(" -----------------------------"))
			/*st = s.slice(s.indexOf("function")+1,s.length);
			s = st[0]
			aux = st.indexOf("function");
			st = aux != -1?st.slice(aux,st.length):"";
			aux = st != ""?"__" + s +"__"+st[1]:"";
			if(st != "") {
				callFunc.push({id:st[1],new_id:aux});
				st[1] = aux;
				let tab = st.indexOf("{");
				st[tab] = "{\n";
				
			}
			st = st != ""?st.join(' '):"";
			funcList.push(st);
			s="";
			st = "";
			aux = "";
			//console.log(chalk.green("TABLA DE SIMBOLOS"));
			//console.log(table);
			this.$ = $$[$0-4] + " " + $$[$0-3] + " " +$$[$0-2] + "\n" + $$[$0-1] + $$[$0] + "\n";*/
			this.$ =  new funcDec(listStmt,$$[$0-3])
	
		
break;
case 22:

			var f = eval('$$');
			//console.log(chalk.red("LA PILA"))
			
			var value;
			var index = 0;
			var parentId = f[2];
			for(let i in f) {
				if(Array.isArray(f[i])) {
					value = f[i];
				}
			}
			if(index != 0) {
				//console.log(chalk.blue(f[index]));
			}
			//console.log(chalk.red("-----------------------"))
			var listStmt = [];
			var innerFunctions = [];
			for(let i in value) {
				//console.log(value[i])
				if(value[i].constructor.name == "translateFunction")
					auxTable.push(value[i])
				else
					listStmt.push(value[i]);
				//console.log(chalk.green("#########"));
			}
			this.$ =  new funcDec(listStmt,null)
				
		
break;
case 24: case 41: case 44: case 51: case 57: case 98: case 105: case 141:
 this.$ = null; 
break;
case 25:
 this.$ = new funcPars($$[$0-4],$$[$0-2],$$[$0]); 
break;
case 26:
 this.$ = new funcPars(null,$$[$0-2],$$[$0]); 
break;
case 29: case 30:
 this.$=$$[$0]; 
break;
case 31:

				/*table.push({"func":JSON.parse(JSON.stringify(innerTable))});
				innerTable = [];
				this.$="";*/
				this.$ = $$[$0];
			
break;
case 37: case 38:
 this.$ = new scapeT($$[$0-1]); 
break;
case 39:
 
				this.$ = new tReturn($$[$0]);
			
break;
case 40:
 this.$ = $$[$0-1];
break;
case 42:
 this.$ = new tIf($$[$0-5],$$[$0-2],$$[$0]);
break;
case 43:
 this.$ = new tIfLast($$[$0]); 
break;
case 45:
 this.$ = new tIfCond($$[$0-5],$$[$0-2],$$[$0]); 
break;
case 46:
 this.$ = new tIfCondElse($$[$0-1]);
break;
case 47:
 
		   this.$ = new twhile($$[$0-4],$$[$0-1]);
	 	
break;
case 48:
 this.$ = new tdowhile($$[$0-6],$$[$0-2]); 
break;
case 49:
 this.$ = new tSwitch($$[$0-5],$$[$0-2],$$[$0-1]); 
break;
case 52:
 this.$ = new tCase($$[$0-4],$$[$0-2],$$[$0]) ; 
break;
case 53:
 this.$ = new tCase(null,$$[$0-2],$$[$0]); 
break;
case 54:
 this.$ = new tLastcase($$[$0-1],$$[$0]); 
break;
case 55:
 this.$ = new tDefcase($$[$0]); 
break;
case 58:
 this.$ = new tFor($$[$0-10],$$[$0-8],$$[$0-6],$$[$0-4],$$[$0-1]);
break;
case 59:
 this.$ = new tFor2($$[$0-10],$$[$0-8],$$[$0-6],$$[$0-4],$$[$0-1]);
break;
case 60:
 this.$ = new tFor3($$[$0-8],$$[$0-6],$$[$0-4],$$[$0-1]);
break;
case 61:
 this.$ = new tFor4($$[$0-6],$$[$0-5],$$[$0-4],$$[$0-1]); 
break;
case 62:
  this.$ = new tForV($$[$0-6],$$[$0-5],$$[$0-4],$$[$0-1]); 
break;
case 67:

				this.$ = new defVarLast($$[$0]);
			
break;
case 68:
this.$=null;
break;
case 69:

				this.$ = new defVarLastP($$[$0-3],$$[$0-1],$$[$0]);
			
break;
case 70:

				this.$ = new defVarLastP(null,$$[$0-1],$$[$0]);
			
break;
case 71:
  
				this.$ = new tAsignVariables($$[$0-3],$$[$0-2],$$[$0-4],$$[$0-1],";");
		  
break;
case 72:
 
			  this.$ = new tVariables($$[$0-2],$$[$0-1],";");
		  
break;
case 73:
 
			  this.$ = new tVariables($$[$0-1],$$[$0],"");
		  
break;
case 74:
 this.$ = new asignLast($$[$0-1],$$[$0]); 
break;
case 76:
 this.$ = new varArrList($$[$0-2],$$[$0]);
break;
case 77:
 this.$ = new varIdList($$[$0-1],$$[$0]); 
break;
case 78:
 this.$ = $$[$0];
break;
case 79:
 this.$ = null;
break;
case 80: case 81: case 82: case 83: case 84:
 
				this.$ = new asignLastF($$[$0-1],$$[$0]);
			
break;
case 85: case 86:
 
				this.$ = new asignLastF($$[$0],null);
			
break;
case 89:

			this.$ = new objType($$[$0-2],$$[$0-1],$$[$0]);
		
break;
case 93:
 this.$ = new tKeyvalueT($$[$0-2],$$[$0]); 
break;
case 96:
 
			this.$ = new defLast($$[$0-2],$$[$0]);
		
break;
case 97:
 
			this.$= new defLast(null,$$[$0]);;  
		
break;
case 99: case 100: case 101: case 102: case 103:
 this.$ = new types($$[$0-1],$$[$0]);
break;
case 106:
 this.$ = new typesL($$[$0-2]); 
break;
case 107:
 this.$ = new typesL(null); 
break;
case 109:
    this.$ = new expObject($$[$0-1]);	
break;
case 110: case 111: case 112: case 113: case 115: case 116: case 117: case 118: case 119: case 120: case 121: case 122: case 123: case 124:
 
		this.$ = new tOperation($$[$0-2],$$[$0-1],$$[$0],$$[$0-2] + $$[$0-1] + $$[$0]);
	
break;
case 114: case 125:
 
		this.$ = new tminus($$[$0-1],$$[$0]);
	
break;
case 126:
 
		this.$ = new expBracket($$[$0-1]);
	
break;
case 127:
 
		this.$ = new ternaryOp($$[$0-4],$$[$0-2],$$[$0]);
	
break;
case 128:

		this.$ = new expRight($$[$0-1],$$[$0]);
	
break;
case 129:
 
		this.$ = new expRight($$[$0-1],$$[$0]);
	
break;
case 130: case 131: case 132: case 133: case 134: case 135:
 
		this.$ = new tnumber($$[$0],$$[$0]);
	
break;
case 136:

		this.$ = new expIdList($$[$0-1],$$[$0]);
	
break;
case 137:
 
		this.$ = new tId($$[$0],null,$$[$0]);
	
break;
case 138:
 
		this.$ = new tLlamadaFunciones($$[$0-4],$$[$0-3],$$[$0-1],"");
	
break;
case 139:
 
		this.$ = new expArrList($$[$0-2],$$[$0]);
	
break;
case 142:
 this.$ = new arrList($$[$0-3],$$[$0-1]); 
break;
case 143:
 this.$ = new arrList(null,$$[$0-1]); 
break;
case 146:
 this.$ = new arrParamList($$[$0-2],$$[$0-1]); 
break;
case 149:
this.$= null;
break;
case 150:
 this.$ = new tObjectParamList($$[$0-2],$$[$0-1],$$[$0]); 
break;
case 152:
 this.$ = new tKeyvalue($$[$0-2],$$[$0]); 
break;
}
},
table: [{3:1,4:2,6:3,7:4,8:5,9:$V0,10:$V1,16:7,17:8,18:9,19:10,20:11,21:12,30:$V2,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},{1:[3]},{5:[1,23],6:24,7:4,8:5,9:$V0,10:$V1,16:7,17:8,18:9,19:10,20:11,21:12,30:$V2,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},o($Va,[2,3]),o($Va,[2,4]),o($Va,[2,5]),{10:[1,25]},o($Va,[2,7]),o($Va,[2,8]),o($Va,[2,9]),o($Va,[2,10]),o($Va,[2,11]),o($Va,[2,12]),{11:$Vb,22:26,23:$Vc,26:28,67:27,68:29,69:$Vd,72:$Ve,73:$Vf,74:$Vg,75:$Vh,76:$Vi,77:$Vj,78:$Vk},{10:[1,39]},{10:[1,40]},{23:[1,41]},{23:[1,42]},{12:[1,43]},{23:[1,44]},{23:[1,45]},{10:[2,94]},{10:[2,95]},{1:[2,1]},o($Va,[2,2]),{11:[1,46]},{23:[1,47]},o($Vl,[2,73],{15:[1,48]}),{11:$Vb,23:$Vm,68:49,73:$Vf,74:$Vg,75:$Vh,76:$Vi,77:$Vj,78:$Vk},o($Vn,[2,75]),{10:$Vo,23:$Vp,43:50,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:[1,62]},{10:$Vo,12:$Vz,23:$Vp,29:63,43:64,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:$Vo,12:$Vz,23:$Vp,29:66,43:64,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:$Vo,12:$Vz,23:$Vp,29:67,43:64,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:$Vo,12:$Vz,23:$Vp,29:68,43:64,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:$Vo,12:$Vz,23:$Vp,29:69,43:64,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},o($Vn,[2,85]),o($Vn,[2,86]),o($VA,$VB,{65:70,11:$VC,33:$VD}),{23:[1,73]},{10:$Vo,23:$Vp,43:74,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:$Vo,23:$Vp,43:75,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{7:78,8:79,10:$V1,16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,35:76,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},{10:$Vo,23:$Vp,43:89,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:$Vo,23:$Vp,43:91,58:[1,90],69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{12:[1,92]},{10:$Vo,12:$Vz,23:$Vp,24:93,25:$VH,27:94,29:95,43:64,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},o($Vl,[2,72]),o($Vn,[2,74]),{70:[1,96],77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP,96:$VQ,97:$VR,98:$VS,99:$VT,100:$VU,101:$VV,102:$VW,103:$VX,105:$VY},{10:$Vo,23:$Vp,43:114,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:$Vo,23:$Vp,43:115,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:$Vo,23:$Vp,43:116,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},o($VZ,[2,130]),o($VZ,[2,131]),o($VZ,[2,132]),o($VZ,[2,133]),o($VZ,[2,134]),o($VZ,[2,135]),o($VZ,[2,137],{26:117,22:118,23:$Vc,69:$Vd,72:$Ve}),{10:$Vo,12:$Vz,23:$Vp,29:121,43:64,69:$Vq,70:$V_,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy,112:119,115:120},o($V$,$V01,{71:122,26:123,69:$Vd,72:$Ve}),o($Vn,[2,80]),o($V11,[2,108],{77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP,96:$VQ,97:$VR,98:$VS,99:$VT,100:$VU,101:$VV,102:$VW,103:$VX,105:$VY}),{10:$V21,14:[2,149],89:124,116:125,117:126},o($Vn,[2,81]),o($Vn,[2,82]),o($Vn,[2,83]),o($Vn,[2,84]),{15:[2,68],28:[1,129],63:128},{10:$V31,34:130,83:$V41,85:$V51,86:$V61,87:$V71},{10:$Vo,12:$Vz,23:$Vp,29:136,43:64,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:[1,139],25:[2,24],31:137,36:138},{25:[1,140],77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP,96:$VQ,97:$VR,98:$VS,99:$VT,100:$VU,101:$VV,102:$VW,103:$VX,105:$VY},{25:[1,141],77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP,96:$VQ,97:$VR,98:$VS,99:$VT,100:$VU,101:$VV,102:$VW,103:$VX,105:$VY},{7:78,8:79,10:$V1,14:[1,142],16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,37:143,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},o($V81,[2,28]),o($V81,[2,29]),o($V81,[2,30]),o($V81,[2,31]),o($V81,[2,32]),o($V81,[2,33]),o($V81,[2,34]),o($V81,[2,35]),o($V81,[2,36]),{15:[1,144]},{15:[1,145]},{10:$Vo,12:$Vz,15:[1,148],23:$Vp,29:147,41:146,43:64,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{25:[1,149],77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP,96:$VQ,97:$VR,98:$VS,99:$VT,100:$VU,101:$VV,102:$VW,103:$VX,105:$VY},{10:[1,150]},{11:[1,151],15:[1,152],59:153,60:$V91,61:$Va1,77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP,96:$VQ,97:$VR,98:$VS,99:$VT,100:$VU,101:$VV,102:$VW,103:$VX,105:$VY},{10:$Vb1,13:156,14:[2,88],79:157,81:158},{25:[1,160]},{25:[2,16],28:[1,161]},o($Vc1,[2,19]),o($V$,$V01,{26:123,71:162,69:$Vd,72:$Ve}),{10:$Vo,23:$Vp,43:163,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:$Vo,23:$Vp,43:164,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:$Vo,23:$Vp,43:165,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:$Vo,23:$Vp,43:166,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:$Vo,23:$Vp,43:167,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:$Vo,23:$Vp,43:168,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:$Vo,23:$Vp,43:169,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:$Vo,23:$Vp,43:170,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:$Vo,23:$Vp,43:171,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:$Vo,23:$Vp,43:172,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:$Vo,23:$Vp,43:173,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:$Vo,23:$Vp,43:174,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:$Vo,23:$Vp,43:175,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:$Vo,23:$Vp,43:176,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:$Vo,23:$Vp,43:177,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},o($VZ,[2,128]),o($VZ,[2,129]),o($VZ,[2,114]),o($VZ,[2,125]),{25:[1,178],77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP,96:$VQ,97:$VR,98:$VS,99:$VT,100:$VU,101:$VV,102:$VW,103:$VX,105:$VY},o($VZ,[2,136],{23:$Vm}),{23:[1,179]},{70:[1,180]},{28:[1,181],70:[2,144]},o($Vd1,[2,147]),o($V$,[2,77]),o($V$,[2,78]),{14:[1,182]},{14:[2,148],15:$Ve1,28:$Vf1,80:183},o($Vg1,[2,151]),{33:[1,186]},{15:[1,187]},{10:[1,189],64:188},{11:[1,190]},o($Vh1,$Vi1,{84:191,88:192,69:$Vj1}),o($Vh1,$Vi1,{88:192,84:194,69:$Vj1}),o($Vh1,$Vi1,{88:192,84:195,69:$Vj1}),o($Vh1,$Vi1,{88:192,84:196,69:$Vj1}),o($Vh1,$Vi1,{88:192,84:197,69:$Vj1}),o($VA,[2,97]),{25:[1,198]},{25:[2,23],28:[1,199]},{33:[1,200]},{12:[1,201]},{12:[1,202]},{47:[1,203]},o($V81,[2,27]),o($V81,[2,37]),o($V81,[2,38]),o($V81,[2,39]),{15:[1,204]},o($V81,[2,41]),{12:[1,205]},{11:[1,206],59:207,60:$V91,61:$Va1},{10:$Vo,23:$Vp,43:208,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:$Vo,23:$Vp,43:209,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:$Vo,23:$Vp,43:210,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},o($Vk1,[2,63]),o($Vk1,[2,64]),{14:[1,211]},{14:[2,87],15:$Ve1,28:$Vf1,80:212},o($Vg1,[2,90]),{33:[1,213]},{15:[1,214]},{10:$Vo,12:$Vz,23:$Vp,29:215,43:64,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},o($V$,[2,76]),o($Vl1,[2,110],{77:$VI,78:$VJ,92:$VM,93:$VN,94:$VO,95:$VP}),o($Vl1,[2,111],{77:$VI,78:$VJ,92:$VM,93:$VN,94:$VO,95:$VP}),o($Vm1,[2,112],{77:$VI,78:$VJ,94:$VO}),o($Vm1,[2,113],{77:$VI,78:$VJ,94:$VO}),o($VZ,[2,115]),o($Vm1,[2,116],{77:$VI,78:$VJ,94:$VO}),o($Vn1,[2,117],{77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP}),o($Vn1,[2,118],{77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP}),o($Vn1,[2,119],{77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP}),o($Vn1,[2,120],{77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP}),o($Vn1,[2,121],{77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP}),o($Vn1,[2,122],{77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP}),o([5,9,10,11,14,15,25,28,30,33,38,39,40,42,47,48,49,53,56,57,58,60,61,70,82,102,103,105],[2,123],{77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP,96:$VQ,97:$VR,98:$VS,99:$VT,100:$VU,101:$VV}),o([5,9,10,11,14,15,25,28,30,33,38,39,40,42,47,48,49,53,56,57,58,60,61,70,82,103,105],[2,124],{77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP,96:$VQ,97:$VR,98:$VS,99:$VT,100:$VU,101:$VV,102:$VW}),{33:[1,216],77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP,96:$VQ,97:$VR,98:$VS,99:$VT,100:$VU,101:$VV,102:$VW,103:$VX,105:$VY},o($VZ,[2,126]),{10:$Vo,12:$Vz,23:$Vp,24:217,25:$VH,27:94,29:95,43:64,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},o($VZ,[2,141],{113:218,114:219,69:[1,220]}),{10:$Vo,12:$Vz,23:$Vp,29:221,43:64,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},o($V11,[2,109]),{10:$V21,117:222},{10:[2,91]},{10:[2,92]},{10:$Vo,12:$Vz,23:$Vp,29:223,43:64,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},o($Vl,[2,71]),{15:[2,67],28:[1,224]},o($VA,$VB,{65:225,11:$VC,33:$VD}),{10:$Vo,12:$Vz,23:$Vp,29:226,43:64,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},o($Vh1,[2,99]),o($Vh1,[2,104],{69:[1,227]}),{70:[1,228]},o($Vh1,[2,100]),o($Vh1,[2,101]),o($Vh1,[2,102]),o($Vh1,[2,103]),{12:[1,231],32:229,33:[1,230]},{10:[1,232]},{10:$V31,34:233,83:$V41,85:$V51,86:$V61,87:$V71},{7:78,8:79,10:$V1,16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,35:234,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},{7:78,8:79,10:$V1,16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,35:235,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},{23:[1,236]},o($V81,[2,40]),{50:237,52:238,53:$Vo1,56:[2,51]},{10:$Vo,23:$Vp,43:240,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:$Vo,23:$Vp,43:241,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{15:[1,242],77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP,96:$VQ,97:$VR,98:$VS,99:$VT,100:$VU,101:$VV,102:$VW,103:$VX,105:$VY},{15:[1,243],77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP,96:$VQ,97:$VR,98:$VS,99:$VT,100:$VU,101:$VV,102:$VW,103:$VX,105:$VY},{25:[1,244],77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP,96:$VQ,97:$VR,98:$VS,99:$VT,100:$VU,101:$VV,102:$VW,103:$VX,105:$VY},{15:[1,245]},{10:$Vb1,81:246},{10:$V31,34:247,83:$V41,85:$V51,86:$V61,87:$V71},o($Vl,[2,13]),o($Vc1,[2,18]),{10:$Vo,23:$Vp,43:248,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{25:[1,249]},o($VZ,[2,139]),o($VZ,[2,140],{69:[1,250]}),{10:$Vo,12:$Vz,23:$Vp,29:121,43:64,69:$Vq,70:$V_,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy,112:251,115:120},o($Vd1,[2,146]),o($Vg1,[2,150]),o($Vg1,[2,152]),{10:[1,252]},o($VA,[2,70]),o($VA,[2,96]),{70:[1,253]},o($Vp1,[2,107]),o($Vl,[2,20]),{10:$V31,34:254,83:$V41,85:$V51,86:$V61,87:$V71},{7:78,8:79,10:$V1,16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,35:255,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},{33:[1,256]},o($Vc1,[2,26]),{7:78,8:79,10:$V1,14:[1,257],16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,37:143,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},{7:78,8:79,10:$V1,14:[1,258],16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,37:143,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},{10:$Vo,23:$Vp,43:259,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{51:260,54:261,56:[1,262]},{53:$Vq1,56:[2,50]},{10:$Vo,23:$Vp,43:264,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{15:[1,265],77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP,96:$VQ,97:$VR,98:$VS,99:$VT,100:$VU,101:$VV,102:$VW,103:$VX,105:$VY},{25:[1,266],77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP,96:$VQ,97:$VR,98:$VS,99:$VT,100:$VU,101:$VV,102:$VW,103:$VX,105:$VY},{10:$Vo,23:$Vp,43:267,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{10:$Vo,23:$Vp,43:268,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{12:[1,269]},o($Va,[2,6]),o($Vg1,[2,89]),o($Vg1,[2,93]),o([5,9,10,11,14,15,25,28,30,33,38,39,40,42,47,48,49,53,56,57,58,60,61,70,82],[2,127],{77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP,96:$VQ,97:$VR,98:$VS,99:$VT,100:$VU,101:$VV,102:$VW,103:$VX,105:$VY}),o($VZ,[2,138]),{10:$Vo,12:$Vz,23:$Vp,29:121,43:64,69:$Vq,70:$V_,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy,112:270,115:120},{70:[1,271]},o($VA,$VB,{65:272,11:$VC,33:$VD}),o($Vp1,[2,106]),{12:[1,273]},{7:78,8:79,10:$V1,14:[1,274],16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,37:143,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},{10:$V31,34:275,83:$V41,85:$V51,86:$V61,87:$V71},o($Vl,$Vr1,{44:276,45:$Vs1}),o($Vl,[2,47]),{25:[1,278],77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP,96:$VQ,97:$VR,98:$VS,99:$VT,100:$VU,101:$VV,102:$VW,103:$VX,105:$VY},{14:[1,279]},{14:[2,57],52:281,53:$Vo1,55:280},{33:[1,282]},{10:$Vo,23:$Vp,43:283,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{33:[1,284],77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP,96:$VQ,97:$VR,98:$VS,99:$VT,100:$VU,101:$VV,102:$VW,103:$VX,105:$VY},{10:$Vo,23:$Vp,43:285,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{12:[1,286]},{15:[1,287],77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP,96:$VQ,97:$VR,98:$VS,99:$VT,100:$VU,101:$VV,102:$VW,103:$VX,105:$VY},{25:[1,288],77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP,96:$VQ,97:$VR,98:$VS,99:$VT,100:$VU,101:$VV,102:$VW,103:$VX,105:$VY},{7:78,8:79,10:$V1,16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,35:289,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},{70:[1,290]},o($Vt1,[2,143]),o($VA,[2,69]),{7:78,8:79,10:$V1,16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,35:291,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},o($Vl,[2,22]),o($Vc1,[2,25]),o($Vl,[2,42]),{12:[1,294],42:[1,293],46:292},{15:[1,295]},o($Vl,[2,49]),{14:[2,54]},{14:[2,56],53:$Vq1},{7:78,8:79,10:$V1,16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,35:296,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},{33:[1,297],77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP,96:$VQ,97:$VR,98:$VS,99:$VT,100:$VU,101:$VV,102:$VW,103:$VX,105:$VY},{7:78,8:79,10:$V1,16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,35:298,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},{15:[1,299],77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP,96:$VQ,97:$VR,98:$VS,99:$VT,100:$VU,101:$VV,102:$VW,103:$VX,105:$VY},{7:78,8:79,10:$V1,16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,35:300,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},{10:$Vo,23:$Vp,43:301,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{12:[1,302]},{7:78,8:79,10:$V1,14:[1,303],16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,37:143,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},o($Vt1,[2,142]),{7:78,8:79,10:$V1,14:[1,304],16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,37:143,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},o($Vl,[2,43]),{23:[1,305]},{7:78,8:79,10:$V1,16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,35:306,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},o($Vl,[2,48]),o([14,53],[2,55],{66:14,7:78,8:79,16:80,17:81,18:82,19:83,20:84,21:85,37:143,10:$V1,30:$V2,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,82:$V9}),{7:78,8:79,10:$V1,16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,35:307,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},o($Vu1,[2,53],{66:14,7:78,8:79,16:80,17:81,18:82,19:83,20:84,21:85,37:143,10:$V1,30:$V2,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,82:$V9}),{10:$Vo,23:$Vp,43:308,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{7:78,8:79,10:$V1,14:[1,309],16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,37:143,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},{25:[1,310],77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP,96:$VQ,97:$VR,98:$VS,99:$VT,100:$VU,101:$VV,102:$VW,103:$VX,105:$VY},{7:78,8:79,10:$V1,16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,35:311,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},o($Vl,[2,62]),o($Vl,[2,21]),{10:$Vo,23:$Vp,43:312,69:$Vq,91:$Vr,104:$Vs,106:$Vt,107:$Vu,108:$Vv,109:$Vw,110:$Vx,111:$Vy},{7:78,8:79,10:$V1,14:[1,313],16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,37:143,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},o($Vu1,[2,52],{66:14,7:78,8:79,16:80,17:81,18:82,19:83,20:84,21:85,37:143,10:$V1,30:$V2,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,82:$V9}),{25:[1,314],77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP,96:$VQ,97:$VR,98:$VS,99:$VT,100:$VU,101:$VV,102:$VW,103:$VX,105:$VY},o($Vl,[2,61]),{12:[1,315]},{7:78,8:79,10:$V1,14:[1,316],16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,37:143,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},{25:[1,317],77:$VI,78:$VJ,90:$VK,91:$VL,92:$VM,93:$VN,94:$VO,95:$VP,96:$VQ,97:$VR,98:$VS,99:$VT,100:$VU,101:$VV,102:$VW,103:$VX,105:$VY},o($Vl,[2,46]),{12:[1,318]},{7:78,8:79,10:$V1,16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,35:319,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},o($Vl,[2,60]),{12:[1,320]},{7:78,8:79,10:$V1,16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,35:321,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},{7:78,8:79,10:$V1,14:[1,322],16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,37:143,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},{7:78,8:79,10:$V1,16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,35:323,37:77,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},{7:78,8:79,10:$V1,14:[1,324],16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,37:143,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},o($Vl,[2,59]),{7:78,8:79,10:$V1,14:[1,325],16:80,17:81,18:82,19:83,20:84,21:85,30:$V2,37:143,38:$VE,39:$VF,40:$VG,42:$V3,47:$V4,48:$V5,49:$V6,57:$V7,58:$V8,66:14,82:$V9},o($Vl,[2,58]),o($Vl,$Vr1,{44:326,45:$Vs1}),o($Vl,[2,45])],
defaultActions: {21:[2,94],22:[2,95],23:[2,1],184:[2,91],185:[2,92],280:[2,54]},
parseError: function parseError (str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    _token_stack:
        var lex = function () {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        };
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};
let s = null;
  let st;
  let aux;
  let funcList = [];
  let callFunc=[];
  let table = [];
  const chalk = require('chalk');
  const deepcopy = require('deepcopy');
  var auxTable = [];
  let innerTable = [];
  let functionTable = [];
  

	const arrList = require('./traductor/arrList.js');
	const arrParamList = require('./traductor/arrParamList.js');
	const asignLast = require('./traductor/asignLast.js');
	const asignLastF = require('./traductor/asignLastF.js');
	const declaracionTypes = require('./traductor/declaracionTypes.js');
	const defLast = require('./traductor/defLast.js');
	const defVarLast = require('./traductor/defVarLast.js');
	const defVarLastP = require('./traductor/defVarLastP.js');
	const expArrList = require('./traductor/expArrList.js');
	const expBracket = require('./traductor/expBracket.js');
	const expIdList = require('./traductor/expIdList.js');
	const expObject = require('./traductor/expObject.js');
	const expRight = require('./traductor/expRight.js');
    const funcDec = require('./traductor/funcDec.js');
	const funcPars = require('./traductor/funcPars.js');
	const objType = require('./traductor/objType.js');
	const paramFuncList = require('./traductor/paramFuncList.js');
	const scapeT = require('./traductor/scapeT.js');
	const tAsignVariables = require('./traductor/tAsignVariables.js');
	const tCase = require('./traductor/tCase.js');
	const tDefcase = require('./traductor/tDefcase.js');
	const tdowhile = require('./traductor/tdowhile.js');
	const ternaryOp = require('./traductor/ternaryOp.js');
	const tFor = require('./traductor/tFor.js');
	const tFo2 = require('./traductor/tFor2.js');
	const tFo3 = require('./traductor/tFor3.js');
	const tFor4 = require('./traductor/tFor4.js');
	const tForV = require('./traductor/tForV.js');
	const tId = require('./traductor/tId.js');
	const tIf = require('./traductor/tIf.js');
	const tIfCond = require('./traductor/tIfCond.js');
	const tIfCondElse = require('./traductor/tIfCondElse.js');
	const tIfLast = require('./traductor/tIfLast.js');
	const tKeyvalue = require('./traductor/tKeyValue.js');
	const tKeyvalueT = require('./traductor/tKeyValueT.js');
	const tLastcase = require('./traductor/tLastcase.js');
	const tLlamadaFunciones = require('./traductor/tLlamadaFunciones.js');
	const tminus = require('./traductor/tminus.js');
	const tnumber = require('./traductor/tnumber.js');
	const tObjectParamList = require('./traductor/tObjectParamList.js');
	const tOperation = require('./traductor/tOperation.js');
	const translateFunction = require('./traductor/translateFunction.js');
	const tReturn = require('./traductor/tReturn.js');
	const tSwitch = require('./traductor/tSwitch.js');
	const tVariables = require('./traductor/tVariables.js');
	const twhile = require('./traductor/twhile.js');
	const types = require('./traductor/types.js');
	const typesL = require('./traductor/typesL.js');
	const varArrList = require('./traductor/varArrList.js');
	const varIdList = require('./traductor/varIdList.js');
	
/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function(match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex () {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin (condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState () {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules () {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState (n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState (condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {"case-sensitive":true},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0://Comentario Linea
break;
case 1://Comentaio Multilinea
break;
case 2:return 39;
break;
case 3:return 38;
break;
case 4:return 110;
break;
case 5:return 9;
break;
case 6:return 82;
break;
case 7:return 58;
break;
case 8:return 82;
break;
case 9:return 30;
break;
case 10:return 42;
break;
case 11:return 45;
break;
case 12:return 47;
break;
case 13:return 48;
break;
case 14:return 49;
break;
case 15:return 53;
break;
case 16:return 56;
break;
case 17:return 57;
break;
case 18:return 60;
break;
case 19:return 61;
break;
case 20:return 83;
break;
case 21:return 85;
break;
case 22:return 86;
break;
case 23:return 87;
break;
case 24:return 108;
break;
case 25:return 109;
break;
case 26:return 111;
break;
case 27:return 40;
break;
case 28:return 73;
break;
case 29:return 74;
break;
case 30:return 75;
break;
case 31:return 76;
break;
case 32:return 12;
break;
case 33:return 14;
break;
case 34:return 23;
break;
case 35:return 25;
break;
case 36:return 28;
break;
case 37:return 15;
break;
case 38:return 33;
break;
case 39:return 72;
break;
case 40:return 77;
break;
case 41:return 78;
break;
case 42:return 90;
break;
case 43:return 91;
break;
case 44:return 94;
break;
case 45:return 92;
break;
case 46:return 93;
break;
case 47:return 95;
break;
case 48:return 98;
break;
case 49:return 99;
break;
case 50:return 96;
break;
case 51:return 97;
break;
case 52:return 100;
break;
case 53:return 11;
break;
case 54:return 101;
break;
case 55:return 102;
break;
case 56:return 103;
break;
case 57:return 104;
break;
case 58:return 105;
break;
case 59:return 69;
break;
case 60:return 70;
break;
case 61:
break;
case 62:
break;
case 63:
break;
case 64:
break;
case 65:return 106;
break;
case 66:return 107;
break;
case 67:return 10;
break;
case 68:return 5;
break;
case 69: console.error('Este es un error léxico: ' + yy_.yytext + ', en la linea: ' + yy_.yylloc.first_line + ', en la columna: ' + yy_.yylloc.first_column); 
break;
}
},
rules: [/^(?:\/\/.*)/,/^(?:[\/][*][^*]*[*]+([^\/*][^*]*[*]+)*[\/])/,/^(?:continue\b)/,/^(?:break\b)/,/^(?:null\b)/,/^(?:type\b)/,/^(?:const\b)/,/^(?:let\b)/,/^(?:const\b)/,/^(?:function\b)/,/^(?:if\b)/,/^(?:else\b)/,/^(?:while\b)/,/^(?:do\b)/,/^(?:switch\b)/,/^(?:case\b)/,/^(?:default\b)/,/^(?:for\b)/,/^(?:in\b)/,/^(?:of\b)/,/^(?:number\b)/,/^(?:boolean\b)/,/^(?:string\b)/,/^(?:void\b)/,/^(?:true\b)/,/^(?:false\b)/,/^(?:undefined\b)/,/^(?:return\b)/,/^(?:\+=)/,/^(?:-=)/,/^(?:\*=)/,/^(?:\/=)/,/^(?:\{)/,/^(?:\})/,/^(?:\()/,/^(?:\))/,/^(?:,)/,/^(?:;)/,/^(?::)/,/^(?:\.)/,/^(?:\+\+)/,/^(?:--)/,/^(?:\+)/,/^(?:-)/,/^(?:\*\*)/,/^(?:\*)/,/^(?:\/)/,/^(?:%)/,/^(?:>=)/,/^(?:<=)/,/^(?:>)/,/^(?:<)/,/^(?:==)/,/^(?:=)/,/^(?:!=)/,/^(?:&&)/,/^(?:\|\|)/,/^(?:!)/,/^(?:\?)/,/^(?:\[)/,/^(?:\])/,/^(?:\s+)/,/^(?:\t+)/,/^(?:\r+)/,/^(?:\n+)/,/^(?:[0-9]+(\.[0-9]+)?\b)/,/^(?:"[^\"]*"|'[^\']*'|`[^\`]*`)/,/^(?:([a-zA-Z$_])[a-zA-Z0-9_$]*)/,/^(?:$)/,/^(?:.)/],
conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = gramatica;
exports.Parser = gramatica.Parser;
exports.parse = function () { return gramatica.parse.apply(gramatica, arguments); };
exports.main = function commonjsMain (args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
}
}).call(this,require('_process'))
},{"./traductor/arrList.js":56,"./traductor/arrParamList.js":57,"./traductor/asignLast.js":58,"./traductor/asignLastF.js":59,"./traductor/declaracionTypes.js":60,"./traductor/defLast.js":61,"./traductor/defVarLast.js":62,"./traductor/defVarLastP.js":63,"./traductor/expArrList.js":64,"./traductor/expBracket.js":65,"./traductor/expIdList.js":66,"./traductor/expObject.js":67,"./traductor/expRight.js":68,"./traductor/funcDec.js":69,"./traductor/funcPars.js":70,"./traductor/objType.js":71,"./traductor/paramFuncList.js":72,"./traductor/scapeT.js":73,"./traductor/tAsignVariables.js":74,"./traductor/tCase.js":75,"./traductor/tDefcase.js":76,"./traductor/tFor.js":77,"./traductor/tFor2.js":78,"./traductor/tFor3.js":79,"./traductor/tFor4.js":80,"./traductor/tForV.js":81,"./traductor/tId.js":82,"./traductor/tIf.js":83,"./traductor/tIfCond.js":84,"./traductor/tIfCondElse.js":85,"./traductor/tIfLast.js":86,"./traductor/tKeyValue.js":87,"./traductor/tKeyValueT.js":88,"./traductor/tLastcase.js":89,"./traductor/tLlamadaFunciones.js":90,"./traductor/tObjectParamList.js":91,"./traductor/tOperation.js":92,"./traductor/tReturn.js":93,"./traductor/tSwitch.js":94,"./traductor/tVariables.js":95,"./traductor/tdowhile.js":96,"./traductor/ternaryOp.js":97,"./traductor/tminus.js":98,"./traductor/tnumber.js":99,"./traductor/translateFunction.js":100,"./traductor/twhile.js":102,"./traductor/types.js":103,"./traductor/typesL.js":104,"./traductor/varArrList.js":105,"./traductor/varIdList.js":106,"_process":112,"chalk":51,"deepcopy":54,"fs":107,"path":111}],45:[function(require,module,exports){
'use strict';

const wrapAnsi16 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${code + offset}m`;
};

const wrapAnsi256 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${38 + offset};5;${code}m`;
};

const wrapAnsi16m = (fn, offset) => (...args) => {
	const rgb = fn(...args);
	return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};

const ansi2ansi = n => n;
const rgb2rgb = (r, g, b) => [r, g, b];

const setLazyProperty = (object, property, get) => {
	Object.defineProperty(object, property, {
		get: () => {
			const value = get();

			Object.defineProperty(object, property, {
				value,
				enumerable: true,
				configurable: true
			});

			return value;
		},
		enumerable: true,
		configurable: true
	});
};

/** @type {typeof import('color-convert')} */
let colorConvert;
const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
	if (colorConvert === undefined) {
		colorConvert = require('color-convert');
	}

	const offset = isBackground ? 10 : 0;
	const styles = {};

	for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
		const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;
		if (sourceSpace === targetSpace) {
			styles[name] = wrap(identity, offset);
		} else if (typeof suite === 'object') {
			styles[name] = wrap(suite[targetSpace], offset);
		}
	}

	return styles;
};

function assembleStyles() {
	const codes = new Map();
	const styles = {
		modifier: {
			reset: [0, 0],
			// 21 isn't widely supported and 22 does the same thing
			bold: [1, 22],
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		color: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],

			// Bright color
			blackBright: [90, 39],
			redBright: [91, 39],
			greenBright: [92, 39],
			yellowBright: [93, 39],
			blueBright: [94, 39],
			magentaBright: [95, 39],
			cyanBright: [96, 39],
			whiteBright: [97, 39]
		},
		bgColor: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49],

			// Bright color
			bgBlackBright: [100, 49],
			bgRedBright: [101, 49],
			bgGreenBright: [102, 49],
			bgYellowBright: [103, 49],
			bgBlueBright: [104, 49],
			bgMagentaBright: [105, 49],
			bgCyanBright: [106, 49],
			bgWhiteBright: [107, 49]
		}
	};

	// Alias bright black as gray (and grey)
	styles.color.gray = styles.color.blackBright;
	styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
	styles.color.grey = styles.color.blackBright;
	styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;

	for (const [groupName, group] of Object.entries(styles)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};

			group[styleName] = styles[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	}

	Object.defineProperty(styles, 'codes', {
		value: codes,
		enumerable: false
	});

	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';

	setLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
	setLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));

	return styles;
}

// Make the export immutable
Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});

},{"color-convert":47}],46:[function(require,module,exports){
/* MIT license */
/* eslint-disable no-mixed-operators */
const cssKeywords = require('color-name');

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

const reverseKeywords = {};
for (const key of Object.keys(cssKeywords)) {
	reverseKeywords[cssKeywords[key]] = key;
}

const convert = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

module.exports = convert;

// Hide .channels and .labels properties
for (const model of Object.keys(convert)) {
	if (!('channels' in convert[model])) {
		throw new Error('missing channels property: ' + model);
	}

	if (!('labels' in convert[model])) {
		throw new Error('missing channel labels property: ' + model);
	}

	if (convert[model].labels.length !== convert[model].channels) {
		throw new Error('channel and label counts mismatch: ' + model);
	}

	const {channels, labels} = convert[model];
	delete convert[model].channels;
	delete convert[model].labels;
	Object.defineProperty(convert[model], 'channels', {value: channels});
	Object.defineProperty(convert[model], 'labels', {value: labels});
}

convert.rgb.hsl = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const min = Math.min(r, g, b);
	const max = Math.max(r, g, b);
	const delta = max - min;
	let h;
	let s;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	const l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	let rdif;
	let gdif;
	let bdif;
	let h;
	let s;

	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const v = Math.max(r, g, b);
	const diff = v - Math.min(r, g, b);
	const diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = 0;
		s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}

		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert.rgb.hwb = function (rgb) {
	const r = rgb[0];
	const g = rgb[1];
	let b = rgb[2];
	const h = convert.rgb.hsl(rgb)[0];
	const w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;

	const k = Math.min(1 - r, 1 - g, 1 - b);
	const c = (1 - r - k) / (1 - k) || 0;
	const m = (1 - g - k) / (1 - k) || 0;
	const y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

function comparativeDistance(x, y) {
	/*
		See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	*/
	return (
		((x[0] - y[0]) ** 2) +
		((x[1] - y[1]) ** 2) +
		((x[2] - y[2]) ** 2)
	);
}

convert.rgb.keyword = function (rgb) {
	const reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	let currentClosestDistance = Infinity;
	let currentClosestKeyword;

	for (const keyword of Object.keys(cssKeywords)) {
		const value = cssKeywords[keyword];

		// Compute comparative distance
		const distance = comparativeDistance(rgb, value);

		// Check if its less, if so set as closest
		if (distance < currentClosestDistance) {
			currentClosestDistance = distance;
			currentClosestKeyword = keyword;
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	let r = rgb[0] / 255;
	let g = rgb[1] / 255;
	let b = rgb[2] / 255;

	// Assume sRGB
	r = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);
	g = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);
	b = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);

	const x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	const y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	const z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	const xyz = convert.rgb.xyz(rgb);
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	const h = hsl[0] / 360;
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;
	let t2;
	let t3;
	let val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	const t1 = 2 * l - t2;

	const rgb = [0, 0, 0];
	for (let i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}

		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	const h = hsl[0];
	let s = hsl[1] / 100;
	let l = hsl[2] / 100;
	let smin = s;
	const lmin = Math.max(l, 0.01);

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	const v = (l + s) / 2;
	const sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	const h = hsv[0] / 60;
	const s = hsv[1] / 100;
	let v = hsv[2] / 100;
	const hi = Math.floor(h) % 6;

	const f = h - Math.floor(h);
	const p = 255 * v * (1 - s);
	const q = 255 * v * (1 - (s * f));
	const t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	const h = hsv[0];
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;
	const vmin = Math.max(v, 0.01);
	let sl;
	let l;

	l = (2 - s) * v;
	const lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	const h = hwb[0] / 360;
	let wh = hwb[1] / 100;
	let bl = hwb[2] / 100;
	const ratio = wh + bl;
	let f;

	// Wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	const i = Math.floor(6 * h);
	const v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	const n = wh + f * (v - wh); // Linear interpolation

	let r;
	let g;
	let b;
	/* eslint-disable max-statements-per-line,no-multi-spaces */
	switch (i) {
		default:
		case 6:
		case 0: r = v;  g = n;  b = wh; break;
		case 1: r = n;  g = v;  b = wh; break;
		case 2: r = wh; g = v;  b = n; break;
		case 3: r = wh; g = n;  b = v; break;
		case 4: r = n;  g = wh; b = v; break;
		case 5: r = v;  g = wh; b = n; break;
	}
	/* eslint-enable max-statements-per-line,no-multi-spaces */

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	const c = cmyk[0] / 100;
	const m = cmyk[1] / 100;
	const y = cmyk[2] / 100;
	const k = cmyk[3] / 100;

	const r = 1 - Math.min(1, c * (1 - k) + k);
	const g = 1 - Math.min(1, m * (1 - k) + k);
	const b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	const x = xyz[0] / 100;
	const y = xyz[1] / 100;
	const z = xyz[2] / 100;
	let r;
	let g;
	let b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// Assume sRGB
	r = r > 0.0031308
		? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let x;
	let y;
	let z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	const y2 = y ** 3;
	const x2 = x ** 3;
	const z2 = z ** 3;
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let h;

	const hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	const c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	const l = lch[0];
	const c = lch[1];
	const h = lch[2];

	const hr = h / 360 * 2 * Math.PI;
	const a = c * Math.cos(hr);
	const b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args, saturation = null) {
	const [r, g, b] = args;
	let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	let ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// Optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	const r = args[0];
	const g = args[1];
	const b = args[2];

	// We use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	const ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	let color = args % 10;

	// Handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	const mult = (~~(args > 50) + 1) * 0.5;
	const r = ((color & 1) * mult) * 255;
	const g = (((color >> 1) & 1) * mult) * 255;
	const b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// Handle greyscale
	if (args >= 232) {
		const c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	let rem;
	const r = Math.floor(args / 36) / 5 * 255;
	const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	const b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	const integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	let colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(char => {
			return char + char;
		}).join('');
	}

	const integer = parseInt(colorString, 16);
	const r = (integer >> 16) & 0xFF;
	const g = (integer >> 8) & 0xFF;
	const b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const max = Math.max(Math.max(r, g), b);
	const min = Math.min(Math.min(r, g), b);
	const chroma = (max - min);
	let grayscale;
	let hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;

	const c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));

	let f = 0;
	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;

	const c = s * v;
	let f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	const h = hcg[0] / 360;
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	const pure = [0, 0, 0];
	const hi = (h % 1) * 6;
	const v = hi % 1;
	const w = 1 - v;
	let mg = 0;

	/* eslint-disable max-statements-per-line */
	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}
	/* eslint-enable max-statements-per-line */

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const v = c + g * (1.0 - c);
	let f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const l = g * (1.0 - c) + 0.5 * c;
	let s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;
	const v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	const w = hwb[1] / 100;
	const b = hwb[2] / 100;
	const v = 1 - b;
	const c = v - w;
	let g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hsv = convert.gray.hsl;

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	const val = Math.round(gray[0] / 100 * 255) & 0xFF;
	const integer = (val << 16) + (val << 8) + val;

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};

},{"color-name":49}],47:[function(require,module,exports){
const conversions = require('./conversions');
const route = require('./route');

const convert = {};

const models = Object.keys(conversions);

function wrapRaw(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];
		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		return fn(args);
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];

		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		const result = fn(args);

		// We're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (let len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(fromModel => {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	const routes = route(fromModel);
	const routeModels = Object.keys(routes);

	routeModels.forEach(toModel => {
		const fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;

},{"./conversions":46,"./route":48}],48:[function(require,module,exports){
const conversions = require('./conversions');

/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	const graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	const models = Object.keys(conversions);

	for (let len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	const graph = buildGraph();
	const queue = [fromModel]; // Unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		const current = queue.pop();
		const adjacents = Object.keys(conversions[current]);

		for (let len = adjacents.length, i = 0; i < len; i++) {
			const adjacent = adjacents[i];
			const node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	const path = [graph[toModel].parent, toModel];
	let fn = conversions[graph[toModel].parent][toModel];

	let cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	const graph = deriveBFS(fromModel);
	const conversion = {};

	const models = Object.keys(graph);
	for (let len = models.length, i = 0; i < len; i++) {
		const toModel = models[i];
		const node = graph[toModel];

		if (node.parent === null) {
			// No possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};


},{"./conversions":46}],49:[function(require,module,exports){
'use strict'

module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

},{}],50:[function(require,module,exports){
'use strict';
module.exports = {
	stdout: false,
	stderr: false
};

},{}],51:[function(require,module,exports){
'use strict';
const ansiStyles = require('ansi-styles');
const {stdout: stdoutColor, stderr: stderrColor} = require('supports-color');
const {
	stringReplaceAll,
	stringEncaseCRLFWithFirstIndex
} = require('./util');

const {isArray} = Array;

// `supportsColor.level` → `ansiStyles.color[name]` mapping
const levelMapping = [
	'ansi',
	'ansi',
	'ansi256',
	'ansi16m'
];

const styles = Object.create(null);

const applyOptions = (object, options = {}) => {
	if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
		throw new Error('The `level` option should be an integer from 0 to 3');
	}

	// Detect level if not set manually
	const colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === undefined ? colorLevel : options.level;
};

class ChalkClass {
	constructor(options) {
		// eslint-disable-next-line no-constructor-return
		return chalkFactory(options);
	}
}

const chalkFactory = options => {
	const chalk = {};
	applyOptions(chalk, options);

	chalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);

	Object.setPrototypeOf(chalk, Chalk.prototype);
	Object.setPrototypeOf(chalk.template, chalk);

	chalk.template.constructor = () => {
		throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
	};

	chalk.template.Instance = ChalkClass;

	return chalk.template;
};

function Chalk(options) {
	return chalkFactory(options);
}

for (const [styleName, style] of Object.entries(ansiStyles)) {
	styles[styleName] = {
		get() {
			const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
			Object.defineProperty(this, styleName, {value: builder});
			return builder;
		}
	};
}

styles.visible = {
	get() {
		const builder = createBuilder(this, this._styler, true);
		Object.defineProperty(this, 'visible', {value: builder});
		return builder;
	}
};

const usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];

for (const model of usedModels) {
	styles[model] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}

for (const model of usedModels) {
	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}

const proto = Object.defineProperties(() => {}, {
	...styles,
	level: {
		enumerable: true,
		get() {
			return this._generator.level;
		},
		set(level) {
			this._generator.level = level;
		}
	}
});

const createStyler = (open, close, parent) => {
	let openAll;
	let closeAll;
	if (parent === undefined) {
		openAll = open;
		closeAll = close;
	} else {
		openAll = parent.openAll + open;
		closeAll = close + parent.closeAll;
	}

	return {
		open,
		close,
		openAll,
		closeAll,
		parent
	};
};

const createBuilder = (self, _styler, _isEmpty) => {
	const builder = (...arguments_) => {
		if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
			// Called as a template literal, for example: chalk.red`2 + 3 = {bold ${2+3}}`
			return applyStyle(builder, chalkTag(builder, ...arguments_));
		}

		// Single argument is hot path, implicit coercion is faster than anything
		// eslint-disable-next-line no-implicit-coercion
		return applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));
	};

	// We alter the prototype because we must return a function, but there is
	// no way to create a function with a different prototype
	Object.setPrototypeOf(builder, proto);

	builder._generator = self;
	builder._styler = _styler;
	builder._isEmpty = _isEmpty;

	return builder;
};

const applyStyle = (self, string) => {
	if (self.level <= 0 || !string) {
		return self._isEmpty ? '' : string;
	}

	let styler = self._styler;

	if (styler === undefined) {
		return string;
	}

	const {openAll, closeAll} = styler;
	if (string.indexOf('\u001B') !== -1) {
		while (styler !== undefined) {
			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			string = stringReplaceAll(string, styler.close, styler.open);

			styler = styler.parent;
		}
	}

	// We can move both next actions out of loop, because remaining actions in loop won't have
	// any/visible effect on parts we add here. Close the styling before a linebreak and reopen
	// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
	const lfIndex = string.indexOf('\n');
	if (lfIndex !== -1) {
		string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
	}

	return openAll + string + closeAll;
};

let template;
const chalkTag = (chalk, ...strings) => {
	const [firstString] = strings;

	if (!isArray(firstString) || !isArray(firstString.raw)) {
		// If chalk() was called by itself or with a string,
		// return the string itself as a string.
		return strings.join(' ');
	}

	const arguments_ = strings.slice(1);
	const parts = [firstString.raw[0]];

	for (let i = 1; i < firstString.length; i++) {
		parts.push(
			String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'),
			String(firstString.raw[i])
		);
	}

	if (template === undefined) {
		template = require('./templates');
	}

	return template(chalk, parts.join(''));
};

Object.defineProperties(Chalk.prototype, styles);

const chalk = Chalk(); // eslint-disable-line new-cap
chalk.supportsColor = stdoutColor;
chalk.stderr = Chalk({level: stderrColor ? stderrColor.level : 0}); // eslint-disable-line new-cap
chalk.stderr.supportsColor = stderrColor;

module.exports = chalk;

},{"./templates":52,"./util":53,"ansi-styles":45,"supports-color":50}],52:[function(require,module,exports){
'use strict';
const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;

const ESCAPES = new Map([
	['n', '\n'],
	['r', '\r'],
	['t', '\t'],
	['b', '\b'],
	['f', '\f'],
	['v', '\v'],
	['0', '\0'],
	['\\', '\\'],
	['e', '\u001B'],
	['a', '\u0007']
]);

function unescape(c) {
	const u = c[0] === 'u';
	const bracket = c[1] === '{';

	if ((u && !bracket && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
		return String.fromCharCode(parseInt(c.slice(1), 16));
	}

	if (u && bracket) {
		return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
	}

	return ESCAPES.get(c) || c;
}

function parseArguments(name, arguments_) {
	const results = [];
	const chunks = arguments_.trim().split(/\s*,\s*/g);
	let matches;

	for (const chunk of chunks) {
		const number = Number(chunk);
		if (!Number.isNaN(number)) {
			results.push(number);
		} else if ((matches = chunk.match(STRING_REGEX))) {
			results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
		} else {
			throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
		}
	}

	return results;
}

function parseStyle(style) {
	STYLE_REGEX.lastIndex = 0;

	const results = [];
	let matches;

	while ((matches = STYLE_REGEX.exec(style)) !== null) {
		const name = matches[1];

		if (matches[2]) {
			const args = parseArguments(name, matches[2]);
			results.push([name].concat(args));
		} else {
			results.push([name]);
		}
	}

	return results;
}

function buildStyle(chalk, styles) {
	const enabled = {};

	for (const layer of styles) {
		for (const style of layer.styles) {
			enabled[style[0]] = layer.inverse ? null : style.slice(1);
		}
	}

	let current = chalk;
	for (const [styleName, styles] of Object.entries(enabled)) {
		if (!Array.isArray(styles)) {
			continue;
		}

		if (!(styleName in current)) {
			throw new Error(`Unknown Chalk style: ${styleName}`);
		}

		current = styles.length > 0 ? current[styleName](...styles) : current[styleName];
	}

	return current;
}

module.exports = (chalk, temporary) => {
	const styles = [];
	const chunks = [];
	let chunk = [];

	// eslint-disable-next-line max-params
	temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
		if (escapeCharacter) {
			chunk.push(unescape(escapeCharacter));
		} else if (style) {
			const string = chunk.join('');
			chunk = [];
			chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
			styles.push({inverse, styles: parseStyle(style)});
		} else if (close) {
			if (styles.length === 0) {
				throw new Error('Found extraneous } in Chalk template literal');
			}

			chunks.push(buildStyle(chalk, styles)(chunk.join('')));
			chunk = [];
			styles.pop();
		} else {
			chunk.push(character);
		}
	});

	chunks.push(chunk.join(''));

	if (styles.length > 0) {
		const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
		throw new Error(errMessage);
	}

	return chunks.join('');
};

},{}],53:[function(require,module,exports){
'use strict';

const stringReplaceAll = (string, substring, replacer) => {
	let index = string.indexOf(substring);
	if (index === -1) {
		return string;
	}

	const substringLength = substring.length;
	let endIndex = 0;
	let returnValue = '';
	do {
		returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
		endIndex = index + substringLength;
		index = string.indexOf(substring, endIndex);
	} while (index !== -1);

	returnValue += string.substr(endIndex);
	return returnValue;
};

const stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
	let endIndex = 0;
	let returnValue = '';
	do {
		const gotCR = string[index - 1] === '\r';
		returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
		endIndex = index + 1;
		index = string.indexOf('\n', endIndex);
	} while (index !== -1);

	returnValue += string.substr(endIndex);
	return returnValue;
};

module.exports = {
	stringReplaceAll,
	stringEncaseCRLFWithFirstIndex
};

},{}],54:[function(require,module,exports){
(function (global,Buffer){
/*!
 * @license deepcopy.js Copyright(c) 2013 sasa+1
 * https://github.com/sasaplus1/deepcopy.js
 * Released under the MIT license.
 *
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.deepcopy = factory());
}(this, (function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var typeDetect = createCommonjsModule(function (module, exports) {
	(function (global, factory) {
		 module.exports = factory() ;
	}(commonjsGlobal, (function () {
	/* !
	 * type-detect
	 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
	var promiseExists = typeof Promise === 'function';

	/* eslint-disable no-undef */
	var globalObject = typeof self === 'object' ? self : commonjsGlobal; // eslint-disable-line id-blacklist

	var symbolExists = typeof Symbol !== 'undefined';
	var mapExists = typeof Map !== 'undefined';
	var setExists = typeof Set !== 'undefined';
	var weakMapExists = typeof WeakMap !== 'undefined';
	var weakSetExists = typeof WeakSet !== 'undefined';
	var dataViewExists = typeof DataView !== 'undefined';
	var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';
	var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';
	var setEntriesExists = setExists && typeof Set.prototype.entries === 'function';
	var mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';
	var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf(new Set().entries());
	var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf(new Map().entries());
	var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
	var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
	var stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === 'function';
	var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());
	var toStringLeftSliceLength = 8;
	var toStringRightSliceLength = -1;
	/**
	 * ### typeOf (obj)
	 *
	 * Uses `Object.prototype.toString` to determine the type of an object,
	 * normalising behaviour across engine versions & well optimised.
	 *
	 * @param {Mixed} object
	 * @return {String} object type
	 * @api public
	 */
	function typeDetect(obj) {
	  /* ! Speed optimisation
	   * Pre:
	   *   string literal     x 3,039,035 ops/sec ±1.62% (78 runs sampled)
	   *   boolean literal    x 1,424,138 ops/sec ±4.54% (75 runs sampled)
	   *   number literal     x 1,653,153 ops/sec ±1.91% (82 runs sampled)
	   *   undefined          x 9,978,660 ops/sec ±1.92% (75 runs sampled)
	   *   function           x 2,556,769 ops/sec ±1.73% (77 runs sampled)
	   * Post:
	   *   string literal     x 38,564,796 ops/sec ±1.15% (79 runs sampled)
	   *   boolean literal    x 31,148,940 ops/sec ±1.10% (79 runs sampled)
	   *   number literal     x 32,679,330 ops/sec ±1.90% (78 runs sampled)
	   *   undefined          x 32,363,368 ops/sec ±1.07% (82 runs sampled)
	   *   function           x 31,296,870 ops/sec ±0.96% (83 runs sampled)
	   */
	  var typeofObj = typeof obj;
	  if (typeofObj !== 'object') {
	    return typeofObj;
	  }

	  /* ! Speed optimisation
	   * Pre:
	   *   null               x 28,645,765 ops/sec ±1.17% (82 runs sampled)
	   * Post:
	   *   null               x 36,428,962 ops/sec ±1.37% (84 runs sampled)
	   */
	  if (obj === null) {
	    return 'null';
	  }

	  /* ! Spec Conformance
	   * Test: `Object.prototype.toString.call(window)``
	   *  - Node === "[object global]"
	   *  - Chrome === "[object global]"
	   *  - Firefox === "[object Window]"
	   *  - PhantomJS === "[object Window]"
	   *  - Safari === "[object Window]"
	   *  - IE 11 === "[object Window]"
	   *  - IE Edge === "[object Window]"
	   * Test: `Object.prototype.toString.call(this)``
	   *  - Chrome Worker === "[object global]"
	   *  - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
	   *  - Safari Worker === "[object DedicatedWorkerGlobalScope]"
	   *  - IE 11 Worker === "[object WorkerGlobalScope]"
	   *  - IE Edge Worker === "[object WorkerGlobalScope]"
	   */
	  if (obj === globalObject) {
	    return 'global';
	  }

	  /* ! Speed optimisation
	   * Pre:
	   *   array literal      x 2,888,352 ops/sec ±0.67% (82 runs sampled)
	   * Post:
	   *   array literal      x 22,479,650 ops/sec ±0.96% (81 runs sampled)
	   */
	  if (
	    Array.isArray(obj) &&
	    (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))
	  ) {
	    return 'Array';
	  }

	  // Not caching existence of `window` and related properties due to potential
	  // for `window` to be unset before tests in quasi-browser environments.
	  if (typeof window === 'object' && window !== null) {
	    /* ! Spec Conformance
	     * (https://html.spec.whatwg.org/multipage/browsers.html#location)
	     * WhatWG HTML$7.7.3 - The `Location` interface
	     * Test: `Object.prototype.toString.call(window.location)``
	     *  - IE <=11 === "[object Object]"
	     *  - IE Edge <=13 === "[object Object]"
	     */
	    if (typeof window.location === 'object' && obj === window.location) {
	      return 'Location';
	    }

	    /* ! Spec Conformance
	     * (https://html.spec.whatwg.org/#document)
	     * WhatWG HTML$3.1.1 - The `Document` object
	     * Note: Most browsers currently adher to the W3C DOM Level 2 spec
	     *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
	     *       which suggests that browsers should use HTMLTableCellElement for
	     *       both TD and TH elements. WhatWG separates these.
	     *       WhatWG HTML states:
	     *         > For historical reasons, Window objects must also have a
	     *         > writable, configurable, non-enumerable property named
	     *         > HTMLDocument whose value is the Document interface object.
	     * Test: `Object.prototype.toString.call(document)``
	     *  - Chrome === "[object HTMLDocument]"
	     *  - Firefox === "[object HTMLDocument]"
	     *  - Safari === "[object HTMLDocument]"
	     *  - IE <=10 === "[object Document]"
	     *  - IE 11 === "[object HTMLDocument]"
	     *  - IE Edge <=13 === "[object HTMLDocument]"
	     */
	    if (typeof window.document === 'object' && obj === window.document) {
	      return 'Document';
	    }

	    if (typeof window.navigator === 'object') {
	      /* ! Spec Conformance
	       * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
	       * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
	       * Test: `Object.prototype.toString.call(navigator.mimeTypes)``
	       *  - IE <=10 === "[object MSMimeTypesCollection]"
	       */
	      if (typeof window.navigator.mimeTypes === 'object' &&
	          obj === window.navigator.mimeTypes) {
	        return 'MimeTypeArray';
	      }

	      /* ! Spec Conformance
	       * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
	       * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
	       * Test: `Object.prototype.toString.call(navigator.plugins)``
	       *  - IE <=10 === "[object MSPluginsCollection]"
	       */
	      if (typeof window.navigator.plugins === 'object' &&
	          obj === window.navigator.plugins) {
	        return 'PluginArray';
	      }
	    }

	    if ((typeof window.HTMLElement === 'function' ||
	        typeof window.HTMLElement === 'object') &&
	        obj instanceof window.HTMLElement) {
	      /* ! Spec Conformance
	      * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
	      * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`
	      * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``
	      *  - IE <=10 === "[object HTMLBlockElement]"
	      */
	      if (obj.tagName === 'BLOCKQUOTE') {
	        return 'HTMLQuoteElement';
	      }

	      /* ! Spec Conformance
	       * (https://html.spec.whatwg.org/#htmltabledatacellelement)
	       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`
	       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
	       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
	       *       which suggests that browsers should use HTMLTableCellElement for
	       *       both TD and TH elements. WhatWG separates these.
	       * Test: Object.prototype.toString.call(document.createElement('td'))
	       *  - Chrome === "[object HTMLTableCellElement]"
	       *  - Firefox === "[object HTMLTableCellElement]"
	       *  - Safari === "[object HTMLTableCellElement]"
	       */
	      if (obj.tagName === 'TD') {
	        return 'HTMLTableDataCellElement';
	      }

	      /* ! Spec Conformance
	       * (https://html.spec.whatwg.org/#htmltableheadercellelement)
	       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`
	       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
	       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
	       *       which suggests that browsers should use HTMLTableCellElement for
	       *       both TD and TH elements. WhatWG separates these.
	       * Test: Object.prototype.toString.call(document.createElement('th'))
	       *  - Chrome === "[object HTMLTableCellElement]"
	       *  - Firefox === "[object HTMLTableCellElement]"
	       *  - Safari === "[object HTMLTableCellElement]"
	       */
	      if (obj.tagName === 'TH') {
	        return 'HTMLTableHeaderCellElement';
	      }
	    }
	  }

	  /* ! Speed optimisation
	  * Pre:
	  *   Float64Array       x 625,644 ops/sec ±1.58% (80 runs sampled)
	  *   Float32Array       x 1,279,852 ops/sec ±2.91% (77 runs sampled)
	  *   Uint32Array        x 1,178,185 ops/sec ±1.95% (83 runs sampled)
	  *   Uint16Array        x 1,008,380 ops/sec ±2.25% (80 runs sampled)
	  *   Uint8Array         x 1,128,040 ops/sec ±2.11% (81 runs sampled)
	  *   Int32Array         x 1,170,119 ops/sec ±2.88% (80 runs sampled)
	  *   Int16Array         x 1,176,348 ops/sec ±5.79% (86 runs sampled)
	  *   Int8Array          x 1,058,707 ops/sec ±4.94% (77 runs sampled)
	  *   Uint8ClampedArray  x 1,110,633 ops/sec ±4.20% (80 runs sampled)
	  * Post:
	  *   Float64Array       x 7,105,671 ops/sec ±13.47% (64 runs sampled)
	  *   Float32Array       x 5,887,912 ops/sec ±1.46% (82 runs sampled)
	  *   Uint32Array        x 6,491,661 ops/sec ±1.76% (79 runs sampled)
	  *   Uint16Array        x 6,559,795 ops/sec ±1.67% (82 runs sampled)
	  *   Uint8Array         x 6,463,966 ops/sec ±1.43% (85 runs sampled)
	  *   Int32Array         x 5,641,841 ops/sec ±3.49% (81 runs sampled)
	  *   Int16Array         x 6,583,511 ops/sec ±1.98% (80 runs sampled)
	  *   Int8Array          x 6,606,078 ops/sec ±1.74% (81 runs sampled)
	  *   Uint8ClampedArray  x 6,602,224 ops/sec ±1.77% (83 runs sampled)
	  */
	  var stringTag = (symbolToStringTagExists && obj[Symbol.toStringTag]);
	  if (typeof stringTag === 'string') {
	    return stringTag;
	  }

	  var objPrototype = Object.getPrototypeOf(obj);
	  /* ! Speed optimisation
	  * Pre:
	  *   regex literal      x 1,772,385 ops/sec ±1.85% (77 runs sampled)
	  *   regex constructor  x 2,143,634 ops/sec ±2.46% (78 runs sampled)
	  * Post:
	  *   regex literal      x 3,928,009 ops/sec ±0.65% (78 runs sampled)
	  *   regex constructor  x 3,931,108 ops/sec ±0.58% (84 runs sampled)
	  */
	  if (objPrototype === RegExp.prototype) {
	    return 'RegExp';
	  }

	  /* ! Speed optimisation
	  * Pre:
	  *   date               x 2,130,074 ops/sec ±4.42% (68 runs sampled)
	  * Post:
	  *   date               x 3,953,779 ops/sec ±1.35% (77 runs sampled)
	  */
	  if (objPrototype === Date.prototype) {
	    return 'Date';
	  }

	  /* ! Spec Conformance
	   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
	   * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
	   * Test: `Object.prototype.toString.call(Promise.resolve())``
	   *  - Chrome <=47 === "[object Object]"
	   *  - Edge <=20 === "[object Object]"
	   *  - Firefox 29-Latest === "[object Promise]"
	   *  - Safari 7.1-Latest === "[object Promise]"
	   */
	  if (promiseExists && objPrototype === Promise.prototype) {
	    return 'Promise';
	  }

	  /* ! Speed optimisation
	  * Pre:
	  *   set                x 2,222,186 ops/sec ±1.31% (82 runs sampled)
	  * Post:
	  *   set                x 4,545,879 ops/sec ±1.13% (83 runs sampled)
	  */
	  if (setExists && objPrototype === Set.prototype) {
	    return 'Set';
	  }

	  /* ! Speed optimisation
	  * Pre:
	  *   map                x 2,396,842 ops/sec ±1.59% (81 runs sampled)
	  * Post:
	  *   map                x 4,183,945 ops/sec ±6.59% (82 runs sampled)
	  */
	  if (mapExists && objPrototype === Map.prototype) {
	    return 'Map';
	  }

	  /* ! Speed optimisation
	  * Pre:
	  *   weakset            x 1,323,220 ops/sec ±2.17% (76 runs sampled)
	  * Post:
	  *   weakset            x 4,237,510 ops/sec ±2.01% (77 runs sampled)
	  */
	  if (weakSetExists && objPrototype === WeakSet.prototype) {
	    return 'WeakSet';
	  }

	  /* ! Speed optimisation
	  * Pre:
	  *   weakmap            x 1,500,260 ops/sec ±2.02% (78 runs sampled)
	  * Post:
	  *   weakmap            x 3,881,384 ops/sec ±1.45% (82 runs sampled)
	  */
	  if (weakMapExists && objPrototype === WeakMap.prototype) {
	    return 'WeakMap';
	  }

	  /* ! Spec Conformance
	   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
	   * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
	   * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``
	   *  - Edge <=13 === "[object Object]"
	   */
	  if (dataViewExists && objPrototype === DataView.prototype) {
	    return 'DataView';
	  }

	  /* ! Spec Conformance
	   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
	   * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
	   * Test: `Object.prototype.toString.call(new Map().entries())``
	   *  - Edge <=13 === "[object Object]"
	   */
	  if (mapExists && objPrototype === mapIteratorPrototype) {
	    return 'Map Iterator';
	  }

	  /* ! Spec Conformance
	   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
	   * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
	   * Test: `Object.prototype.toString.call(new Set().entries())``
	   *  - Edge <=13 === "[object Object]"
	   */
	  if (setExists && objPrototype === setIteratorPrototype) {
	    return 'Set Iterator';
	  }

	  /* ! Spec Conformance
	   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
	   * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
	   * Test: `Object.prototype.toString.call([][Symbol.iterator]())``
	   *  - Edge <=13 === "[object Object]"
	   */
	  if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
	    return 'Array Iterator';
	  }

	  /* ! Spec Conformance
	   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
	   * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
	   * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``
	   *  - Edge <=13 === "[object Object]"
	   */
	  if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
	    return 'String Iterator';
	  }

	  /* ! Speed optimisation
	  * Pre:
	  *   object from null   x 2,424,320 ops/sec ±1.67% (76 runs sampled)
	  * Post:
	  *   object from null   x 5,838,000 ops/sec ±0.99% (84 runs sampled)
	  */
	  if (objPrototype === null) {
	    return 'Object';
	  }

	  return Object
	    .prototype
	    .toString
	    .call(obj)
	    .slice(toStringLeftSliceLength, toStringRightSliceLength);
	}

	return typeDetect;

	})));
	});

	const isBufferExists = typeof Buffer !== 'undefined';
	const isBufferFromExists = isBufferExists && typeof Buffer.from !== 'undefined';

	const isBuffer = isBufferExists
	  ? /**
	     * is value is Buffer?
	     *
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isBuffer(value) {
	      return Buffer.isBuffer(value);
	    }
	  : /**
	     * return false
	     *
	     * NOTE: for Buffer unsupported
	     *
	     * @return {boolean}
	     */
	    function isBuffer() {
	      return false;
	    };

	const copy = isBufferFromExists
	  ? /**
	     * copy Buffer
	     *
	     * @param {Buffer} value
	     * @return {Buffer}
	     */
	    function copy(value) {
	      return Buffer.from(value);
	    }
	  : isBufferExists
	  ? /**
	     * copy Buffer
	     *
	     * NOTE: for old node.js
	     *
	     * @param {Buffer} value
	     * @return {Buffer}
	     */
	    function copy(value) {
	      return new Buffer(value);
	    }
	  : /**
	     * shallow copy
	     *
	     * NOTE: for Buffer unsupported
	     *
	     * @param {*}
	     * @return {*}
	     */
	    function copy(value) {
	      return value;
	    };

	/**
	 * detect type of value
	 *
	 * @param {*} value
	 * @return {string}
	 */
	function detectType(value) {
	  // NOTE: isBuffer must execute before type-detect,
	  // because type-detect returns 'Uint8Array'.
	  if (isBuffer(value)) {
	    return 'Buffer';
	  }

	  return typeDetect(value);
	}

	/**
	 * collection types
	 */
	const collectionTypeSet = new Set([
	  'Arguments',
	  'Array',
	  'Map',
	  'Object',
	  'Set'
	]);

	/**
	 * get value from collection
	 *
	 * @param {Array|Object|Map|Set} collection
	 * @param {string|number|symbol} key
	 * @param {string} [type=null]
	 * @return {*}
	 */
	function get(collection, key, type = null) {
	  const valueType = type || detectType(collection);

	  switch (valueType) {
	    case 'Arguments':
	    case 'Array':
	    case 'Object':
	      return collection[key];
	    case 'Map':
	      return collection.get(key);
	    case 'Set':
	      // NOTE: Set.prototype.keys is alias of Set.prototype.values
	      // it means key is equals value
	      return key;
	  }
	}

	/**
	 * check to type string is collection
	 *
	 * @param {string} type
	 */
	function isCollection(type) {
	  return collectionTypeSet.has(type);
	}

	/**
	 * set value to collection
	 *
	 * @param {Array|Object|Map|Set} collection
	 * @param {string|number|symbol} key
	 * @param {*} value
	 * @param {string} [type=null]
	 * @return {Array|Object|Map|Set}
	 */
	function set(collection, key, value, type = null) {
	  const valueType = type || detectType(collection);

	  switch (valueType) {
	    case 'Arguments':
	    case 'Array':
	    case 'Object':
	      collection[key] = value;
	      break;
	    case 'Map':
	      collection.set(key, value);
	      break;
	    case 'Set':
	      collection.add(value);
	      break;
	  }

	  return collection;
	}

	const freeGlobalThis =
	  typeof globalThis !== 'undefined' &&
	  globalThis !== null &&
	  globalThis.Object === Object &&
	  globalThis;

	const freeGlobal =
	  typeof global !== 'undefined' &&
	  global !== null &&
	  global.Object === Object &&
	  global;

	const freeSelf =
	  typeof self !== 'undefined' &&
	  self !== null &&
	  self.Object === Object &&
	  self;

	const globalObject =
	  freeGlobalThis || freeGlobal || freeSelf || Function('return this')();

	/**
	 * copy ArrayBuffer
	 *
	 * @param {ArrayBuffer} value
	 * @return {ArrayBuffer}
	 */
	function copyArrayBuffer(value) {
	  return value.slice(0);
	}

	/**
	 * copy Boolean
	 *
	 * @param {Boolean} value
	 * @return {Boolean}
	 */
	function copyBoolean(value) {
	  return new Boolean(value.valueOf());
	}

	/**
	 * copy DataView
	 *
	 * @param {DataView} value
	 * @return {DataView}
	 */
	function copyDataView(value) {
	  // TODO: copy ArrayBuffer?
	  return new DataView(value.buffer);
	}

	/**
	 * copy Buffer
	 *
	 * @param {Buffer} value
	 * @return {Buffer}
	 */
	function copyBuffer(value) {
	  return copy(value);
	}

	/**
	 * copy Date
	 *
	 * @param {Date} value
	 * @return {Date}
	 */
	function copyDate(value) {
	  return new Date(value.getTime());
	}

	/**
	 * copy Number
	 *
	 * @param {Number} value
	 * @return {Number}
	 */
	function copyNumber(value) {
	  return new Number(value);
	}

	/**
	 * copy RegExp
	 *
	 * @param {RegExp} value
	 * @return {RegExp}
	 */
	function copyRegExp(value) {
	  return new RegExp(value.source, value.flags);
	}

	/**
	 * copy String
	 *
	 * @param {String} value
	 * @return {String}
	 */
	function copyString(value) {
	  return new String(value);
	}

	/**
	 * copy TypedArray
	 *
	 * @param {*} value
	 * @return {*}
	 */
	function copyTypedArray(value, type) {
	  const typedArray = globalObject[type];

	  if (typedArray.from) {
	    return globalObject[type].from(value);
	  }

	  return new globalObject[type](value);
	}

	/**
	 * shallow copy
	 *
	 * @param {*} value
	 * @return {*}
	 */
	function shallowCopy(value) {
	  return value;
	}

	/**
	 * get empty Array
	 *
	 * @return {Array}
	 */
	function getEmptyArray() {
	  return [];
	}

	/**
	 * get empty Map
	 *
	 * @return {Map}
	 */
	function getEmptyMap() {
	  return new Map();
	}

	/**
	 * get empty Object
	 *
	 * @return {Object}
	 */
	function getEmptyObject() {
	  return {};
	}

	/**
	 * get empty Set
	 *
	 * @return {Set}
	 */
	function getEmptySet() {
	  return new Set();
	}

	var copyMap = new Map([
	  // deep copy
	  ['ArrayBuffer', copyArrayBuffer],
	  ['Boolean', copyBoolean],
	  ['Buffer', copyBuffer],
	  ['DataView', copyDataView],
	  ['Date', copyDate],
	  ['Number', copyNumber],
	  ['RegExp', copyRegExp],
	  ['String', copyString],

	  // typed arrays
	  // TODO: pass bound function
	  ['Float32Array', copyTypedArray],
	  ['Float64Array', copyTypedArray],
	  ['Int16Array', copyTypedArray],
	  ['Int32Array', copyTypedArray],
	  ['Int8Array', copyTypedArray],
	  ['Uint16Array', copyTypedArray],
	  ['Uint32Array', copyTypedArray],
	  ['Uint8Array', copyTypedArray],
	  ['Uint8ClampedArray', copyTypedArray],

	  // shallow copy
	  ['Array Iterator', shallowCopy],
	  ['Map Iterator', shallowCopy],
	  ['Promise', shallowCopy],
	  ['Set Iterator', shallowCopy],
	  ['String Iterator', shallowCopy],
	  ['function', shallowCopy],
	  ['global', shallowCopy],
	  // NOTE: WeakMap and WeakSet cannot get entries
	  ['WeakMap', shallowCopy],
	  ['WeakSet', shallowCopy],

	  // primitives
	  ['boolean', shallowCopy],
	  ['null', shallowCopy],
	  ['number', shallowCopy],
	  ['string', shallowCopy],
	  ['symbol', shallowCopy],
	  ['undefined', shallowCopy],

	  // collections
	  // NOTE: return empty value, because recursively copy later.
	  ['Arguments', getEmptyArray],
	  ['Array', getEmptyArray],
	  ['Map', getEmptyMap],
	  ['Object', getEmptyObject],
	  ['Set', getEmptySet]

	  // NOTE: type-detect returns following types
	  // 'Location'
	  // 'Document'
	  // 'MimeTypeArray'
	  // 'PluginArray'
	  // 'HTMLQuoteElement'
	  // 'HTMLTableDataCellElement'
	  // 'HTMLTableHeaderCellElement'

	  // TODO: is type-detect never return 'object'?
	  // 'object'
	]);

	/**
	 * no operation
	 */
	function noop() {}

	/**
	 * copy value
	 *
	 * @param {*} value
	 * @param {string} [type=null]
	 * @param {Function} [customizer=noop]
	 * @return {*}
	 */
	function copy$1(value, type = null, customizer = noop) {
	  if (arguments.length === 2 && typeof type === 'function') {
	    customizer = type;
	    type = null;
	  }

	  const valueType = type || detectType(value);
	  const copyFunction = copyMap.get(valueType);

	  if (valueType === 'Object') {
	    const result = customizer(value, valueType);

	    if (result !== undefined) {
	      return result;
	    }
	  }

	  // NOTE: TypedArray needs pass type to argument
	  return copyFunction ? copyFunction(value, valueType) : value;
	}

	/**
	 * deepcopy function
	 *
	 * @param {*} value
	 * @param {Object|Function} [options]
	 * @return {*}
	 */
	function deepcopy(value, options = {}) {
	  if (typeof options === 'function') {
	    options = {
	      customizer: options
	    };
	  }

	  const {
	    // TODO: before/after customizer
	    customizer
	    // TODO: max depth
	    // depth = Infinity,
	  } = options;

	  const valueType = detectType(value);

	  if (!isCollection(valueType)) {
	    return recursiveCopy(value, null, null, null);
	  }

	  const copiedValue = copy$1(value, valueType, customizer);

	  const references = new WeakMap([[value, copiedValue]]);
	  const visited = new WeakSet([value]);

	  return recursiveCopy(value, copiedValue, references, visited);
	}

	/**
	 * recursively copy
	 *
	 * @param {*} value target value
	 * @param {*} clone clone of value
	 * @param {WeakMap} references visited references of clone
	 * @param {WeakSet} visited visited references of value
	 * @param {Function} customizer user customize function
	 * @return {*}
	 */
	function recursiveCopy(value, clone, references, visited, customizer) {
	  const type = detectType(value);
	  const copiedValue = copy$1(value, type);

	  // return if not a collection value
	  if (!isCollection(type)) {
	    return copiedValue;
	  }

	  let keys;

	  switch (type) {
	    case 'Arguments':
	    case 'Array':
	      keys = Object.keys(value);
	      break;
	    case 'Object':
	      keys = Object.keys(value);
	      keys.push(...Object.getOwnPropertySymbols(value));
	      break;
	    case 'Map':
	    case 'Set':
	      keys = value.keys();
	      break;
	  }

	  // walk within collection with iterator
	  for (let collectionKey of keys) {
	    const collectionValue = get(value, collectionKey, type);

	    if (visited.has(collectionValue)) {
	      // for [Circular]
	      set(clone, collectionKey, references.get(collectionValue), type);
	    } else {
	      const collectionValueType = detectType(collectionValue);
	      const copiedCollectionValue = copy$1(collectionValue, collectionValueType);

	      // save reference if value is collection
	      if (isCollection(collectionValueType)) {
	        references.set(collectionValue, copiedCollectionValue);
	        visited.add(collectionValue);
	      }

	      set(
	        clone,
	        collectionKey,
	        recursiveCopy(
	          collectionValue,
	          copiedCollectionValue,
	          references,
	          visited),
	        type
	      );
	    }
	  }

	  // TODO: isSealed/isFrozen/isExtensible

	  return clone;
	}

	return deepcopy;

})));


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"buffer":109}],55:[function(require,module,exports){
const parser = require('./ejecucion.js');
const Scope = require('./ejecucion/Scope.js');
const translate = require('./EjecutarTraductor');
const parserAST = require('./AST.js');

let scope = null;
let tablaErrores = null;
//const mermaid = require('mermaid');
//const chalk = require('chalk');

$(document).ready(function(){
	//code here...
	var code = $(".codemirror-textarea")[0];
	var editor = CodeMirror.fromTextArea(code, {
        lineNumbers : true,
        mode: 'javascript'
    });
    
    var code_translate = $(".codemirror-translate")[0];
    var editor_translate = CodeMirror.fromTextArea(code_translate, {
        lineNumbers : true,
        mode: 'javascript'
    });

    var consoleT = document.getElementsByClassName('console')[0];
    var treeDiv = document.getElementById("merTree");
    
    document.getElementById("ejecutar").onclick = function() {
        let entrada = editor.getValue();
        consoleT.value = "";
        ejecutar(entrada,consoleT);
    }
    document.getElementById("Arbol").onclick = function() {
        let entrada = editor.getValue();
        consoleT.value = "";
        var str = "graph TD; \n"+AST(entrada);
        //treeDiv.innerHTML = str;

        var insertSvg = function(svgCode, bindFunctions){
            treeDiv.innerHTML = svgCode;
        };
        
        var graph = mermaid.mermaidAPI.render('graphDiv', str, insertSvg);

        mermaid.initialize({startOnLoad:true});
        mermaid.init();
        
    }

    document.getElementById("tabla").onclick = function() {
        var table = document.getElementById("table-ts");
        table.innerHTML = "";
        if(scope != null) {

            var tab = scope.getTable();
            var type = scope.getTypesTable();
            var func = scope.getFunctionTable();

            
            var str = "<h2>Variables</h2>\n";
            str += "<table>\n"
            str += "<tr>\n" +
                   "<th>Nombre</th>\n"+
                   "<th>Tipo</th>\n" +
                   "<th>Valor</th>\n" +
                   "<th>Ambito</th>\n" +
                   "</tr>\n";
            for(let obj of tab) {
                str += "<tr>\n"
                str += "<th>" + obj[0] + "</th>\n";
                str += "<th>" + obj[1].type + "</th>\n";
                str += "<th>" + getValue(obj[1]) + "</th>\n";
                str += "<th>1</th>";
            }
            str += "</table>\n";
            str += "<h2>Funciones</h2>\n";
            str += "<table>\n"
            str += "<tr>\n" +
                   "<th>Nombre</th>\n"+
                   "<th>Tipo</th>\n" +
                   "<th>Ambito</th>\n" +
                   "</tr>\n";
            for(let obj of func) {
                str += "<tr>\n"
                str += "<th>" + obj[0] + "</th>\n";
                str += "<th>" + obj[1].type + "</th>\n";
                str += "<th>1</th>";
            }
            str += "</table>\n";
            str += "<h2>Types</h2>\n";
            str += "<table>\n"
            str += "<tr>\n" +
                   "<th>Nombre</th>\n"+
                   //"<th>Tipo</th>\n" +
                   "</tr>\n";
            for(let obj of type) {
                str += "<tr>\n"
                str += "<th>" + obj[0] + "</th>\n";
               // str += "<th>" + obj[1].type + "</th>\n";
                //str += "<th>1</th>";
            }
            str += "</table>\n";
            table.innerHTML = str;
        }
    }

    document.getElementById("traducir").onclick = function() {
        let entrada = editor_translate.getValue();
        consoleT.value = "";
        traducir(entrada,editor);
    }

    document.getElementById("traducir-ejecutar").onclick = function() {
        let entrada = editor_translate.getValue();
        consoleT.value = "";
        var traduccion = traducir(entrada,editor);
        ejecutar(traduccion,consoleT);
    }
});

function traducir(entrada,editor) {
    var r = translate(entrada);
    editor.getDoc().setValue(r);
    return r;
}

function getValue(obj) {
    //console.log(obj);
    if(obj.value instanceof Map) {
        return getStrObj(obj.value,"");
    } else if(obj.value.isArray) {
        return getStrArr(obj.value.value);
    } else {
        return obj.value.value;
    }
}

function getStrArr(obj) {
    var str = "["
    var prop = "";
    //console.log(obj)
    obj.forEach((value) => {

        //prop += tab + "\t"+ key + ": ";
        if(value.constructor.name == "TObject") {
            prop += value.value;
        } else if(value.isArray) {
            prop += getStrArr(value.value)
        } else if(value.constructor.name == "Map"){
            prop += getStrObj(value,"\t");
        }
        prop += ",";
    });
    prop = prop.substring(0,prop.length-1)
    str += prop;
    str += "]"
    return str;
}

function getStrObj(obj,tab) {
    var str = tab+"{\n"
    var prop = "";
    obj.forEach((value,key) => {

        prop += tab + "\t"+ key + ": ";
        if(value.constructor.name == "TObject") {
            prop += value.value;
        } else if(value.isArray) {
            prop += getStrArr(value.value)
        } else if(value.constructor.name == "Map"){
            prop += getStrObj(value,"\t");
        }
        prop += ",\n";
    });
    prop = prop.substring(0,prop.length-2)
    str += prop;
    str += "\n"
    str += tab +"}"
    return str;
}

function AST(entrada) {
    let ast = parserAST.parse(entrada.toString());
    console.log(ast)
    return ast.code;
}

function ejecutar(entrada,consoleT) {

    //console.log(console);
    
parser.tablaErrores = [];

let ast = parser.parse(entrada.toString());

tablaErrores = null;

scope = new Scope(null);

consoleT.value = "";

tablaErrores = ast.tabla;
ast = ast.ast;
var ts = document.getElementById("table");
ts.innerHTML = "";


if(tablaErrores.length > 0) {
    var str_ = "<table>\n";
    str_ += "<tr>\n" +
                   "<th>Linea</th>\n"+
                   "<th>Columna</th>\n" +
                   "<th>Tipo</th>\n" +
                   "<th>Mensaje</th>\n" +
                   "</tr>\n";
    tablaErrores.forEach(element => {
        str_ += "<tr>\n" +
                   "<th>"+element.line+"</th>\n"+
                   "<th>"+element.column+"</th>\n" +
                   "<th>"+element.type+"</th>\n" +
                   "<th>"+element.msg+"</th>\n" +
                   "</tr>\n";

    });
    str_ += "</table>\n";
    ts.innerHTML = str_;
    while(tablaErrores.length != 0) {
        tablaErrores.pop()
    }
    //return;
}

ast.forEach(element => {
    if(element.constructor.name == "decType") {
        element.run(scope,consoleT);
    }
})

ast.forEach(element => {
    if(element.constructor.name == "Variable" ||element.constructor.name == "asignVariable" ) {
        element.run(scope,consoleT);
    }
})

ast.forEach(element => {
    if(element.constructor.name == "Function") {
        element.run(scope,consoleT);
    }
})

ast.forEach(element => {
    if(check(element))
        element.run(scope,consoleT)
});

}

function check(element) {
    if(element.constructor.name == "Function") {
        return false;
    } else if(element.constructor.name == "Variable" ||element.constructor.name == "asignVariable" ) {
        return false;
    } else if(element.constructor.name == "decType") {
        return false;
    } else {
        return true;
    }
}

},{"./AST.js":1,"./EjecutarTraductor":3,"./ejecucion.js":4,"./ejecucion/Scope.js":21}],56:[function(require,module,exports){
class arrList {

    constructor(list,arrParam) {
        this.list = list;
        this.arrParam = arrParam;
    }

    translate(scope,cond,sTable,funcId) {
        
        if(list != null) {
            var l = this.list.translate(scope,cond,sTable,funcId);
            var arr = "";
            if(this.arrParam != null) {
                arr = this.arrParam.translate(this.list.translate(scope,cond,sTable,funcId));
            }
            return l + "[" + arr +"]";
        }

        var aux = "";
        if(this.arrParam != null) {
            aux = this.arrParam.translate(this.list.translate(scope,cond,sTable,funcId));     
        }

        return "[" + aux + "]";
    }
}

module.exports = arrList;
},{}],57:[function(require,module,exports){
class arrParamList {

    constructor(list,exp) {
        this.list = list;
        this.exp = exp;
    }

    translate(scope,cond,sTable,funcId) {
        var l = this.list.translate(scope,cond,sTable,funcId);
        var e = this.exp.translate(scope,cond,sTable,funcId);

        return l + ", " + e;
    }
}

module.exports = arrParamList;
},{}],58:[function(require,module,exports){
class asignLast {

    constructor(list,asign) {
        this.list = list;
        this.asign = asign;
    }

    translate(scope,cond,sTable,funcId) {
        var l = this.list.translate(scope,cond,sTable,funcId);
        var a = this.asign.translate(scope,cond,sTable,funcId);

        return l + a;
    }
}

module.exports = asignLast;
},{}],59:[function(require,module,exports){
class asignLastF {

    constructor(op,exp) {
        this.op = op;
        this.exp = exp;
    }

    translate(scope,cond,sTable,funcId) {
        if(this.exp != null) {
            return " " + this.op + " " + this.exp.translate(scope,cond,sTable,funcId);
        }

        return this.op;
    }
}

module.exports = asignLastF;
},{}],60:[function(require,module,exports){
class declaracionTypes {

    constructor(id,obj) {
        this.id = id;
        this.obj = obj;
    }

    translate(scope,cond,sTable,funcId) {
        var ob = "";
        if(this.obj != null) {
            ob = this.obj.translate(scope,cond,sTable,funcId);
        }

        scope.insertVariable(this.id,"type"," = {\n"+ob+"}\n")
        return "Type " + this.id + " = {\n"+ob+"}\n"; 

    }
}
module.exports = declaracionTypes;
},{}],61:[function(require,module,exports){
class defLast {

    constructor(types,exp) {
        this.types = types;
        this.exp = exp;
    }

    translate(scope,cond,sTable,funcId) {

        if(this.types != null) {
            var t = this.types.translate(scope,cond,sTable,funcId);
           
            return " : " + t + " = " + this.exp.translate(scope,cond,sTable,funcId);
        }

        return " = " + this.exp.translate(scope,cond,sTable,funcId);
    }
}

module.exports = defLast;
},{}],62:[function(require,module,exports){
class defVarLast {

    constructor(defVarLastP) {
        this.defVarLastP = defVarLastP;
    }

    translate(scope,cond,sTable,funcId) {
        return ", " + this.defVarLastP.translate(scope,cond,sTable,funcId);
    }
}

module.exports = defVarLast;
},{}],63:[function(require,module,exports){
const defVarLast = require("./defVarLast");

class defVarLastP {

    constructor(list,id,deflast) {
        this.list = list;
        this.id = id;
        this.deflast = deflast;
    }

    translate(scope,cond,sTable,funcId) {
        var exp = "";

        scope.insertVariable(this.id,"","");
        if(this.deflast != null) {
            exp = this.deflast.translate(scope,cond,sTable,funcId);
        }

        if(this.list != null) {
            var l = this.list.translate(scope,cond,sTable,funcId);
            return l + ", " + this.id + " " +exp;
        }

        return this.id + " "+exp;
        
    }
}

module.exports = defVarLastP;

},{"./defVarLast":62}],64:[function(require,module,exports){
class expArrList {

    constructor(arrParam,sqBEnd) {
        this.arrParam = arrParam;
        this.sqBEnd = sqBEnd;
    }

    translate(scope,cond,sTable,funcId) {
        var arr = "";
        if(this.arrParam != null) {
            arr = this.arrParam.translate(scope,cond,sTable,funcId);
        }
        var sq = "";
        if(this.sqBEnd != null) {
            sq = this.sqBEnd.translate(scope,cond,sTable,funcId);
        }
        return "[" + arr + "]" + sq;
    }
}

module.exports = expArrList;
},{}],65:[function(require,module,exports){
class expBracket {

    constructor(exp) {
        this.exp = exp;
    }

    translate(scope,cond,sTable,funcId) {
        return "(" + this.exp.translate(scope,cond,sTable,funcId) + ")";
    }
}

module.exports = expBracket;
},{}],66:[function(require,module,exports){
class expIdList {

    constructor(id, varLast) {
        this.id = id;
        this.varLast = varLast;
    }

    translate(scope,cond,sTable,funcId) {
        return this.id + this.varLast.translate(scope,cond,sTable,funcId);
    }
}

module.exports = expIdList;
},{}],67:[function(require,module,exports){
class expObject {

    constructor(objparams) {
        this.objparams = objparams;
    }

    translate(scope,cond,sTable,funcId) {
        if(this.objparams != null) {
            var params = this.objparams.translate(scope,cond,sTable,funcId);
            return "{ " + params+ " }"; 
        }
        return "{ }";
    }
}

module.exports = expObject;
},{}],68:[function(require,module,exports){
class expRight {

    constructor(exp,op) {
        this.exp = exp;
        this.op = op;
    }

    translate(scope,cond,sTable,funcId) {
        return this.exp.translate(scope,cond,sTable,funcId) + this.op;
    }
}

module.exports = expRight;
},{}],69:[function(require,module,exports){
class funcDec {

    constructor(STMT,type) {
        this.STMT = STMT;
        this.type = type;
    }

    translate(scope,cond,sTable,funcId) {
        var f = "";
        if(this.type != null) {
            f = " : " + this.type.translate(scope,cond,sTable,funcId);
        }
         var r = "";
         this.STMT.forEach(element => {
             r += element.translate(scope,cond,sTable,funcId) + "\n";
         });
         return f + "{\n"+ r + "\n}\n";
    }

}

module.exports = funcDec;
},{}],70:[function(require,module,exports){
class funcPars {

    constructor(list,id,type) {
        this.list = list;
        this.id = id;
        this.type = type;
    }

    translate(scope,cond,sTable,funcId) {

        scope.insertVariable(this.id,"","");

        var l = "";
        if(this.list != null) {
            l = this.list.translate(scope,cond,sTable,funcId);
            l = l + ", ";
        }
        var t = this.type.translate(scope,cond,sTable,funcId);
        return l + this.id + " : " + t;
    }
}
module.exports = funcPars;
},{}],71:[function(require,module,exports){
class objType {

    constructor(list,point,key) {
        this.list = list;
        this.point = point;
        this.key = key;
    }

    translate(scope,cond,sTable,funcId) {
        var l = this.list.translate(scope,cond,sTable,funcId);
        //var p = this.point.translate(scope,cond,sTable,funcId);
        var k = this.key.translate(scope,cond,sTable,funcId);

        return l + this.point + "\n" + k;
    }
}
module.exports = objType;
},{}],72:[function(require,module,exports){
class paramFuncList {

    constructor(parFuncList,exp) {
        this.parFuncList = parFuncList;
        this.exp = exp;
    }

    translate(scope,cond,sTable,funcId) {
        if(this.parFuncList != null) {
            var param = this.parFuncList.translate(scope,cond,sTable,funcId);
            
            return param + ", " + this.exp.translate(scope,cond,sTable,funcId);
        }
        return this.exp.translate(scope,cond,sTable,funcId);
    }
}

module.exports = paramFuncList;
},{}],73:[function(require,module,exports){
class scapeT {

    constructor(op) {
        this.op = op;
    }

    translate(scope,cond,sTable,funcId) {
        return this.op + ";";
    }
}
module.exports = scapeT;
},{}],74:[function(require,module,exports){
class tAsignVariables {

    constructor(id,exp, decVar, defVarLast,str) {
        this.id = id;
        this.exp = exp;
        this.decVar = decVar;
        this.defVarLast = defVarLast;
        this.str = str;
    }

    translate(scope,cond,sTable,funcId) {

        if(funcId != null) {
            let aa = sTable.filter(element => {
                if(element.parentId == funcId) {
                    return element;
                }
            });
            
            if(aa.length > 0) {
                var b = aa.filter(element => {
                    if(element.id == this.id) {
                        return element;
                    }
                });

                if(b.length > 0) {
                    scope.insertVariableGlobally(funcId+"__"+this.id,this.decVar,"");
                    var a = "";
                    if(this.exp != null) {
                        a = this.exp.translate(scope,cond,sTable,funcId);
                    }

                    var defL = "";
                    if(this.defVarLast != null) {
                        defL = this.defVarLast.translate(scope,cond,sTable,funcId);
                        defL = defL.substr(2);
                        defL = this.decVar +" " + defL;
                    }

                    return funcId+"__"+this.id + "" + a +this.str + "\n"  + defL;
                }
            }
        } /*else {
            var a = "";
            if(this.exp != null) {
                a = this.exp.translate(scope,cond,sTable,funcId);
            }
            if(a != "") {
                a = "" + a;
            }
            scope.insertVariable(this.id,this.decVar,a);
        }*/

        var a = "";
        if(this.exp != null) {
            a = this.exp.translate(scope,cond,sTable,funcId);
        }
        scope.insertVariable(this.id,this.decVar,a);
        var def = "";
        if(this.defVarLast != null) {
            def = this.defVarLast.translate(scope,cond,sTable,funcId);
        }

        return this.decVar + " " + this.id + a + def +this.str;
    }

}

module.exports = tAsignVariables;
},{}],75:[function(require,module,exports){
const tscope = require('./translateScope');
class tCase {

    constructor(list,exp,stmt) {
        this.list = list;
        this.exp = exp;
        this.stmt = stmt;
    }
    
    translate(scope,cond,sTable,funcId) {
        var l = "";
        var ex = this.exp.translate(scope,cond,sTable,funcId);
        var st = "";

        var newScope = new tscope(scope);
        this.stmt.forEach(element => {
            st += element.translate(newScope,cond,sTable,funcId);
            st += "\n";
        });

        if(this.list != null) {
            l = this.list.translate(scope,cond,sTable,funcId) + "\n";

            return l + "case " + ex + ":\n" + st;
        }

        return "case " + ex + ":\n" + st
    }
}

module.exports = tCase;
},{"./translateScope":101}],76:[function(require,module,exports){
const tscope = require('./translateScope');
class tDefcase {

    constructor(stmt) {
        this.stmt = stmt;
    }

    translate(scope,cond,sTable,funcId) {
        var st ="";
        var newScope = new tscope(scope);
        this.stmt.forEach(element => {
            st += element.translate(newScope,cond,sTable,funcId);
            st += "\n";
        });

        return "default :" + st;
    }
}
module.exports = tDefcase;
},{"./translateScope":101}],77:[function(require,module,exports){
const tscope = require('./translateScope');
class tFor {

    constructor(id,exp,cond,inc,stmt) {
        this.id = id;
        this.exp = exp;
        this.cond = cond;
        this.inc = inc;
        this.stmt = stmt;
    }

    translate(scope,cond,sTable,funcId) {
        var newScope = new tscope(scope);

        newScope.insertVariable(this.id,"","");
        
        var e = this.exp.translate(newScope,cond,sTable,funcId);
        
        var cond_ = this.cond.translate(newScope,cond,sTable,funcId);
        var inc_ = this.inc.translate(newScope,cond,sTable,funcId);

        var st = "";
        this.stmt.forEach(element => {
            st += element.translate(newScope,cond,sTable,funcId);
            st += "\n";
        });

        return "for( let " + this.id + " = "+ e +"; " + cond_ + "; " + inc_ +") {\n" + st + "}\n";
    }
}
module.exports = tFor;
},{"./translateScope":101}],78:[function(require,module,exports){
const tscope = require('./translateScope');
class tFor2 {

    constructor(asign,exp,cond,inc,stmt) {
        this.asign = asign;
        this.exp = exp;
        this.cond = cond;
        this.inc = inc;
        this.stmt = stmt;
    }

    translate(scope,cond,sTable,funcId) {
        var newScope = new tscope(scope);

        var asign_ = this.asign.translate(newScope,cond,sTable,funcId);
        var e = this.exp.translate(newScope,cond,sTable,funcId);
        var cond_ = this.cond.translate(newScope,cond,sTable,funcId);
        var inc_ = this.inc.translate(newScope,cond,sTable,funcId);

        var st = "";
        this.stmt.forEach(element => {
            st += element.translate(newScope,cond,sTable,funcId);
            st += "\n";
        });

        return "for(" + asign_ + " = "+ e +"; " + cond_ + "; " + inc_ +") {\n" + st + "}\n";
    }
}
module.exports = tFor2;
},{"./translateScope":101}],79:[function(require,module,exports){
const tscope = require('./translateScope');
class tFor3 {

    constructor(asign,cond,inc,stmt) {
        this.asign = asign;
        this.cond = cond;
        this.inc = inc;
        this.stmt = stmt;
    }

    translate(scope,cond,sTable,funcId) {
        var newScope = new tscope(scope);


        var asign_ = this.asign.translate(newScope,cond,sTable,funcId);
        var cond_ = this.cond.translate(newScope,cond,sTable,funcId);
        var inc_ = this.inc.translate(newScope,cond,sTable,funcId);

        var st = "";
        this.stmt.forEach(element => {
            st += element.translate(newScope,cond,sTable,funcId);
            st += "\n";
        });

        return "for(" + asign_ + "; " + cond_ + "; " + inc_ +") {\n" + st + "}\n";
    }
}
module.exports = tFor3;
},{"./translateScope":101}],80:[function(require,module,exports){
const tscope = require('./translateScope');
class tFor4 {

    constructor(id,op,exp,stmt) {
        this.id = id;
        this.op = op;
        this.exp = exp;
        this.stmt = stmt;
    }

    translate(scope,cond,sTable,funcId) {
        var newScope = new tscope(scope);

        newScope.insertVariable(this.id,"","");

        var e = this.exp.translate(newScope,cond,sTable,funcId);
        var st = "";
        this.stmt.forEach(element => {
            st += element.translate(newScope,cond,sTable,funcId);
            st += "\n";
        });

        return "for( let " + this.id + " " + this.op + " " + e +") {\n" + st + "}\n";
    }
}
module.exports = tFor4;
},{"./translateScope":101}],81:[function(require,module,exports){
const tscope = require('./translateScope');
class tForV {

    constructor(variable,op,exp,stmt) {
        this.variable = variable;
        this.op = op;
        this.exp = exp;
        this.stmt = stmt;
    }

    translate(scope,cond,sTable,funcId) {
        var newScope = new tscope(scope);

        var var_ = this.variable.translate(newScope,cond,sTable,funcId);
        var ops = this.op.translate(newScope,cond,sTable,funcId);
        var e = this.exp.translate(newScope,cond,sTable,funcId);
        var st = "";

        this.stmt.forEach(element => {
            st += element.translate(newScope,cond,sTable,funcId);
            st += "\n";
        });

        return "for("+var_ +" " + ops + " " + e + ") {\n" + st +"}\n";
    }
}

module.exports = tForV;
},{"./translateScope":101}],82:[function(require,module,exports){
class tId {

    constructor(id,property,str){
        this.id = id;
        this.property = property;
        this.str = str;
    }

    translate(scope,cond,sTable,funcId) {
        
        
        if(cond != null) {
            if(!scope.existVariable(this.id)) {
                if(sTable != null) {
                    sTable.push({parentId:cond,id:this.id});
                    return cond + "__" + this.id;
                }
                if(funcId != null) {
                    return funcId + "__"+this.id;
                }
            }
            //scope.varUse.push({funcParent:cond,prop:this.id});
            //console.log(scope);
        }

        if(!scope.existVariable(this.id)) {
            
            if(funcId != null) {
                return funcId + "__"+this.id;
            }
        }
        return this.id;

    }
}

module.exports = tId;
},{}],83:[function(require,module,exports){
const tscope = require('./translateScope');
class tIf {

    constructor(exp,stmt,iflast) {
        this.exp = exp;
        this.stmt = stmt;
        this.iflast = iflast;
    }

    translate(scope,cond,sTable,funcId) {
        var e = this.exp.translate(scope,cond,sTable,funcId);
        var st = "";
        var newScope = new tscope(scope);
        this.stmt.forEach(element => {
            st += element.translate(newScope,cond,sTable,funcId);
            st += "\n";
        });
        var last = "";
        if(this.iflast != null) {
            last = this.iflast.translate(scope,cond,sTable,funcId);
        } else {
            last = "\n";
        }

        return "if(" + e + ") {\n" + st + "\n} " + last;
    }
}

module.exports = tIf;
},{"./translateScope":101}],84:[function(require,module,exports){
const tscope = require('./translateScope');
class tIfCond {

    constructor(exp,stmt,iflast) {
        this.exp = exp;
        this.stmt = stmt;
        this.iflast = iflast;
    }

    translate(scope,cond,sTable,funcId) {
        var e = this.exp.translate(scope,cond,sTable,funcId);
        var st = "";
        var newScope = new tscope(scope);
        this.stmt.forEach(element => {
            st += element.translate(newScope,cond,sTable,funcId);
            st += "\n";
        });
        var last ="";
        if(this.iflast != null) {
            last = " "+this.iflast.translate(scope,cond,sTable,funcId);
        } else {
            last = "\n";
        }

        return "if(" + e +"){\n" + st +"\n}"+last;
    }
}

module.exports = tIfCond;
},{"./translateScope":101}],85:[function(require,module,exports){
const tscope = require('./translateScope');
class tIfCondElse {

    constructor(stmt) {
        this.stmt = stmt;
    }

    translate(scope,cond,sTable,funcId) {
        var newScope = new tscope(scope);
        var st = "";
        this.stmt.forEach(element => {
            st += element.translate(newScope,cond,sTable,funcId);
            st += "\n";
        });

        return " {\n" + st + "\n}\n";
    }
}
module.exports = tIfCondElse;
},{"./translateScope":101}],86:[function(require,module,exports){
class tIfLast {

    constructor(ifcond) {
        this.ifcond = ifcond;
    }

    translate(scope,cond,sTable,funcId) {
        return "else " + this.ifcond.translate(scope,cond,sTable,funcId);
    }
}

module.exports = tIfLast;
},{}],87:[function(require,module,exports){

class tKeyValue {

    constructor(id,exp) {
        this.id = id;
        this.exp = exp;
    }

    translate(scope,cond,sTable,funcId) {
        return this.id + ": " + this.exp.translate(scope,cond,sTable,funcId);
    }
}

module.exports = tKeyValue;
},{}],88:[function(require,module,exports){
class tKeyValueT {

    constructor(id, type) {
        this.id = id;
        this.type = type;
    }

    translate(scope,cond,sTable,funcId) {
        var t = this.type.translate(scope,cond,sTable,funcId);

        return this.id + " : " + t;
    }
}

module.exports = tKeyValueT;
},{}],89:[function(require,module,exports){
const defLast = require("./defLast");

class tLastcase {
    constructor(defcase,endcase) {
        this.defcase = defcase;
        this.endcase = endcase;
    }

    translate(scope,cond,sTable,funcId) {
        var a = this.defcase.translate(scope,cond,sTable,funcId);
        var b = this.endcase.translate(scope,cond,sTable,funcId);

        return a + "\n" +b;
    }
}

module.exports = tLastcase;
},{"./defLast":61}],90:[function(require,module,exports){
class tLlamadaFunciones {

    constructor(id , varlast, paramFunc,str) {
        this.id = id;
        this.varlast = varlast;
        this.paramFunc = paramFunc;
        this.str = str;
    }

    translate(scope,cond,sTable,funcId) {
        var par = "";
        var val = "";
        if(this.varlast != null) {
            val = this.varlast.translate(scope,cond,sTable,funcId);
        }
        if(this.paramFunc != null) {
            par = this.paramFunc.translate(scope,cond,sTable,funcId);
        }


        if(funcId != null || funcId != undefined) {
            if(scope.searchFunction(this.id,funcId)){
                return funcId+"__"+this.id + "("+par+")" + this.str;
            }
        }
        return this.id +val+ "("+par+")" + this.str;
    }

}

module.exports = tLlamadaFunciones;
},{}],91:[function(require,module,exports){
class tObjectParamList {

    constructor(list,point,keyValue) {
        this.list = list;
        this.point = point;
        this.keyValue = keyValue;
    }

    translate(scope,cond,sTable,funcId) {
        var l = this.list.translate(scope,cond,sTable,funcId);
        var key = this.keyValue.translate(scope,cond,sTable,funcId);
        return l + this.point + " "+ key;
    }
}

module.exports = tObjectParamList;
},{}],92:[function(require,module,exports){
class tOperation {

    constructor(exp1,op,exp2,str) {
        this.exp1 = exp1;
        this.op = op;
        this.exp2 = exp2;
        this.str = str;
    }

    translate(scope,cond,sTable,funcId) {
        var a1 = this.exp1.translate(scope,cond,sTable,funcId);
        var a2 = this.exp2.translate(scope,cond,sTable,funcId);
        
        
        return String(a1 + this.op + a2);
    }

}

module.exports = tOperation;
},{}],93:[function(require,module,exports){
class tReturn {

    constructor(exp) {
        this.exp = exp;
    }

    translate(scope,cond,sTable,funcId) {
        if(this.exp != null) {
            var a = this.exp.translate(scope,cond,sTable,funcId);
            return "return " + a + ";";
        }

        return "return;"
    }

}

module.exports = tReturn;
},{}],94:[function(require,module,exports){
class tSwitch {

    constructor(exp,firstcase,lastcase) {
        this.exp = exp;
        this.firstcase = firstcase;
        this.lastcase = lastcase;
    }

    translate(scope,cond,sTable,funcId) {
        var e = this.exp.translate(scope,cond,sTable,funcId);
        var fcase = "";
        var lcase = "";
        if(this.firstcase != null) {
            fcase = this.firstcase.translate(scope,cond,sTable,funcId);

        }

        if(this.lcase != null) {
            lcase = "\n"+this.lastcase.translate(scope,cond,sTable,funcId);
        }

        return "switch(" + e + ") {\n" + fcase + lcase + "\n}\n";
    }
}
module.exports = tSwitch;
},{}],95:[function(require,module,exports){
class tVariables {

    constructor(id,exp ,str) {
        this.id = id;
        this.exp = exp;
        this.str = str;
    }

    translate(scope,cond,sTable,funcId) {
        var ex = this.exp.translate(scope,cond,sTable,funcId)
        return this.id + ex + this.str;
    }

}

module.exports = tVariables;
},{}],96:[function(require,module,exports){
const tscope = require('./translateScope');
class tdowhile {

    constructor(stmt,exp) {
        this.stmt = stmt;
        this.exp = exp;
    }

    translate(scope,cond,sTable,funcId) {
        var newScope = new tscope(scope);
        var e = this.exp.translate(scope,cond,sTable,funcId);
        var s = "";
        this.stmt.forEach(element => {
            s += element.translate(newScope,cond,sTable,funcId);
            s += "\n";
        });

        return "do {\n"+s+"\n} while(" + e + ");";
    }
}

module.exports = tdowhile;
},{"./translateScope":101}],97:[function(require,module,exports){
class ternaryOp {

    constructor(exp1,exp2,exp3) {
        this.exp1 = exp1;
        this.exp2 = exp2;
        this.exp3 = exp3;
    }

    translate(scope,cond,sTable,funcId) {
        var ex1 = this.exp1.translate(scope,cond,sTable,funcId);
        var ex2 = this.exp2.translate(scope,cond,sTable,funcId);
        var ex3 = this.exp3.translate(scope,cond,sTable,funcId);
        return ex1 + "?" + ex2 + ":" + ex3;
    }
}

module.exports = ternaryOp;
},{}],98:[function(require,module,exports){
class tminus {

    constructor(op,exp) {
        this.op = op;
        this.exp = exp;
    }

    translate(scope,cond,sTable,funcId) {
        var a1 = this.exp.translate(scope,cond,sTable,funcId);
        
        return String(this.op + a1);
    }

}

module.exports = tminus;
},{}],99:[function(require,module,exports){
class tnumber {

    constructor(exp ,str) {
        this.exp = exp;
        this.str = str;
    }

    translate(scope,cond,sTable,funcId) {
        
        return this.exp;
    }

}

module.exports = tnumber;
},{}],100:[function(require,module,exports){
const tscope = require('./translateScope');
class translateFunction {
    constructor(id,funcDec,pars) {
        this.id = id;
        this.funcDec = funcDec;
        this.pars = pars;
    }
    translate(scope,cond,sTable,funcId) {
        var newScope = new tscope(scope);

        var args = "";
        if(this.pars != null) {
            args = this.pars.translate(newScope,cond,sTable,funcId)
        }

        if(cond != null || cond != undefined) {
            scope.insertFunctionGlobally(this.id,cond);
            return "function " + cond + "__" + this.id + " "+ "("+args+") " + this.funcDec.translate(newScope,cond,sTable,funcId) + "\n";
        }

        return "function " + this.id + " "+ "("+args+") " + this.funcDec.translate(newScope,cond,sTable,this.id) + "\n";
        
    }
}

module.exports = translateFunction;
},{"./translateScope":101}],101:[function(require,module,exports){

class translateScope{

    constructor(prev) {
        this.prev = prev;
        this.table = [];
        this.varUse = [];
        this.innerFunc = [];
    }

    existVariable(id) {
        var sc= this;

        for(sc = this;sc != null;sc = sc.prev){
            for(let i in sc.table) {
                if(sc.table[i].id == id) {
                    return true;
                }
            }
        }
        return false;
    }

    insertVariable(id,varDec,value) {
        this.table.push({id:id,varDec,value:value});
    }

    insertVariableGlobally(id,varDec,value) {
        var sc= this;
        while(sc.prev != null || sc.prev != undefined) {
         
            sc = sc.prev;
        }
        sc.insertVariable(id,varDec,value);
    }

    printScope() {
        var sc;
        for(sc = this;sc != null;sc = sc.prev){
            console.log(sc.table);
        }
    }

    insertFunctionGlobally(id,parentF) {
        var sc= this;
        while(sc.prev != null || sc.prev != undefined) {
         
            sc = sc.prev;
        }
        sc.innerFunc.push({id:id,parent:parentF});
    }

    searchFunction(id,parent) {
        var sc= this;
        while(sc.prev != null || sc.prev != undefined) {
         
            sc = sc.prev;
        }
        if(sc.innerFunc.length > 0) {
            for(let i in sc.innerFunc) {
                var element = sc.innerFunc[i];
                if(element.parent == parent && element.id == id) {
                    return true;
                }
            }
        }
        return false;
    }
}

module.exports = translateScope;
},{}],102:[function(require,module,exports){
const tscope = require('./translateScope');
class twhile {

    constructor(exp,stmt) {
        this.exp = exp;
        this.stmt = stmt;
    }

    translate(scope,cond,sTable,funcId) {
        var e = this.exp.translate(scope,cond,sTable,funcId);
        var s = "";

        var newScope = new tscope(scope);
        this.stmt.forEach(element => {
            s += element.translate(newScope,cond,sTable,funcId);
            s += "\n";
        });

        return "while("+e+") {\n"+s+"}\n";
    }
}

module.exports = twhile;
},{"./translateScope":101}],103:[function(require,module,exports){
class types {

    constructor(type, list) {
        this.type = type;
        this.list = list;
    }

    translate(scope,cond,sTable,funcId) {
        var l = "";
        if(this.list != null) {
            l = " " +this.list.translate(scope,cond,sTable,funcId);
        }

        return this.type + l;
    }
}

module.exports = types;
},{}],104:[function(require,module,exports){
class typesL {

    constructor(list) {
        this.list = list;
    }

    translate(scope,cond,sTable,funcId) {
        
        if(this.list != null) {
            return this.list.translate(scope,cond,sTable,funcId) + "[]";
        }

        return "[]";
    }
}

module.exports = typesL;
},{}],105:[function(require,module,exports){
class varArrList {

    constructor(exp,auxP) {
        this.exp = exp;
        this.auxP = auxP;
    }

    translate(scope,cond,sTable,funcId){
        var aux = "";
        if(this.auxP != null) {
            aux = this.auxP.translate(scope,cond,sTable,funcId);
        }
        var ex = this.exp.translate(scope,cond,sTable,funcId);
        return "[" + ex + "]" + aux;
    }
}
module.exports = varArrList;
},{}],106:[function(require,module,exports){
class varIdList {

    constructor(id, auxP) {
        this.id = id;
        this.auxP = auxP;
    }

    translate(scope,cond,sTable,funcId) {
        var aux = "";
        if(this.auxP != null) {
            aux = this.auxP.translate(scope,cond,sTable,funcId);
        }
        return "."+this.id + aux;
    }
}

module.exports = varIdList;
},{}],107:[function(require,module,exports){

},{}],108:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],109:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this,require("buffer").Buffer)
},{"base64-js":108,"buffer":109,"ieee754":110}],110:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],111:[function(require,module,exports){
(function (process){
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":112}],112:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}]},{},[55]);
